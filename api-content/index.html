{"posts":[{"title":"Github Action 中自动打包 Windows Python EXE 文件","content":"这样非常便捷，本地打包经常需要 ↑ 找命令和清理文件，很累 官方的文档 ：构建和测试 Python 下面是一份模板 # 工作流程名称 name: Build exe on: # 允许用户手动触发工作流程 workflow_dispatch: # 仓库收到 push 和 pr 时触发工作流程 push: branches: [&quot;master&quot;] pull_request: branches: [&quot;master&quot;] # GITHUB_TOKEN 的权限 permissions: contents: read jobs: build: # 指定运行环境 runs-on: windows-latest # 任务步骤 steps: # 拉取仓库代码（必须） - uses: actions/checkout@v4.1.5 # 设置 Python 版本 - name: Set up Python uses: actions/setup-python@v5.1.0 with: python-version: &quot;3.10&quot; # 从缓存中安装 pip (跳过下载过程) cache: &quot;pip&quot; # pip 安装依赖 - name: Install dependencies run: | python -m pip install --upgrade pip pip install -r requirements.txt # 打包 exe - name: Package run: | pyinstaller -F xx1.py pyinstaller -F xx2.py # 上传结果为 artifact - name: Upload results uses: actions/upload-artifact@v4.3.3 with: # 结果名(无论写什么，结果始终是zip最后) name: result_exe # 结果文件（可以是单个文件，多个文件） path: dist # 压缩级别(默认0, 0-9, 0 为不压缩) compression-level: 0 # 保留时间(默认90) retention-days: 90 安装 vscode 插件后可以通过悬浮查看命令注释和 Ctrl 自动跳转项目 use 的项目版本建议手动查看并更新一下@vx.x.x 最好不要有中文在关键的地方 构建过程着实有点慢了，需要 4 到 10 分钟甚至更多 ","link":"https://blog.xn--fiqz59cpva341l.top/post/github-action-zhong-zi-dong-da-bao-windows-python-exe-wen-jian/"},{"title":"终端美化指南 (WIN/LINUX)","content":" windows 终端 一、 ohmyposh 安装指南 打开 powershell 依次执行 winget install JanDeDobbeleer.OhMyPosh -s winget $env:Path += &quot;;C:\\Users\\user\\AppData\\Local\\Programs\\oh-my-posh\\bin&quot; New-Item -Path $PROFILE -Type File -Force notepad $PROFILE 添加 oh-my-posh init pwsh | Invoke-Expression . $PROFILE 二、字体 1. 自动安装 oh-my-posh font install 2. 自选安装 进入 www.nerdfonts.com 选择喜欢的字体安装 3. 更换字体 记得在终端设置里面更换安装的字体 三、 自动补全 依次执行 Install-Module PSReadLine Import-Module PSReadLine Set-PSReadLineOption -PredictionSource History notepad $profile 添加 # Shows navigable menu of all options when hitting Tab Set-PSReadlineKeyHandler -Key Tab -Function MenuComplete # Autocompletion for arrow keys Set-PSReadlineKeyHandler -Key UpArrow -Function HistorySearchBackward Set-PSReadlineKeyHandler -Key DownArrow -Function HistorySearchForward # auto suggestions Import-Module PSReadLine Set-PSReadLineOption -PredictionSource History Liunx 终端 一、 ZSH 依次输入 apt install zsh chsh -s /bin/zsh 输入密码即可 二、 oh my zsh 安装 wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 三、 添加插件 cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc ZSH_CUSTOM=~/.oh-my-zsh/custom # 自动高亮 git clone https://github.com/zsh-users/zsh-syntax-highlighting $ZSH_CUSTOM/plugins/zsh-syntax-highlighting # 自动提示 git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions # 自动补全 git clone https://github.com/zsh-users/zsh-completions $ZSH_CUSTOM/plugins/zsh-completions ! grep -q &quot;autoload -U compinit &amp;&amp; compinit&quot; ~/.zshrc &amp;&amp; echo &quot;autoload -U compinit &amp;&amp; compinit&quot; &gt;&gt; ~/.zshrc sed -i '/^plugins=/c\\plugins=(git sudo z zsh-syntax-highlighting zsh-autosuggestions zsh-completions)' ~/.zshrc 四、添加主题 git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k sed -i '/^ZSH_THEME=/c\\ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot;' ~/.zshrc 重新进入终端即可开始配置主题 配置不满意？重新开始配置 p10k configure ","link":"https://blog.xn--fiqz59cpva341l.top/post/zhong-duan-mei-hua-zhi-nan-winlinux/"},{"title":"在 Vue 中使用 Pinia","content":"Pinia 符合直觉的 Vue.js 状态管理库 (localStorage 超级进化版本) 一、 基本使用 想要在 vue 项目中使用主要有以下几个步骤 1. 安装 pinia npm install pinia 2. 初始化（改写 main.js） 添加以下内容 // 导入 import { createPinia } from &quot;pinia&quot;; // 创建对象 const pinia = createPinia(); 同时需要在默认 app 上添加 pinia // 原本可能是这样 // createApp(App).mount(&quot;#app&quot;); // 需要改写成下面的样子 const app = createApp(App); app.mount(&quot;#app&quot;); //添加这个 app.use(pinia); 3. 定义 store 在 vue 项目的 src 目录下新建文件夹 stores 在 stores 下新建一个 xueStore.js (文件名随意) 文件内容基本格式如下 import { defineStore } from &quot;pinia&quot;; import { ref } from &quot;vue&quot;; // 名字规范：use{yourStoreName}Store export const useXueStore = defineStore(&quot;xue&quot;, () =&gt; { // 这里写一些东西 const name = ref(&quot;雪中明月&quot;); const level = ref(18); const levelUp = () =&gt; { level.value++; }; // 注意要 return return { name, level, levelUp }; }); 4. 使用 store 现在万事具备，你可以在项目随意使用了 找到一个组件，例如 App.vue &lt;script setup&gt; import { useXueStore } from &quot;./stores/xueStore&quot;; const XueStore = useXueStore(); &lt;/script&gt; 只需两步即可获取 store ，接下来试试使用里面的内容，补全 template 部分 &lt;template&gt; name: {{ XueStore.name }} &lt;br /&gt; age: {{ XueStore.level }} &lt;br /&gt; &lt;button @click=&quot;XueStore.levelUp&quot;&gt;levelUp&lt;/button&gt; &lt;/template&gt; 二、 数据持久化 不难发现，网页一刷新，上面的数据就会变成初始值，也许这不是我们大概不是我们想要的 我们需要添加一个 pinia 插件 pinia-plugin-persistedstate 1. 安装插件 npm install pinia-plugin-persistedstate 2. 初始化（改写 main.js） 添加以下内容 // 导入 import piniaPluginPersistedstate from &quot;pinia-plugin-persistedstate&quot;; 同时需要在 pinia 上添加 插件 pinia.use(piniaPluginPersistedstate); 3. 开始使用 配置很简单，只需要添加一行 { persist: true; } 依旧是 xueStore.js import { defineStore } from &quot;pinia&quot;; import { ref } from &quot;vue&quot;; export const useXueStore = defineStore( &quot;xue&quot;, () =&gt; { const name = ref(&quot;雪中明月&quot;); const level = ref(18); const levelUp = () =&gt; { level.value++; }; return { name, level, levelUp }; }, // 在这里添加一行,记得添加上面的**逗号** { persist: true } ); 注意：到此插件会按照默认配置进行本地化， 如果需要进一步的自定义 请查阅：插件配置 Doc 4. 对比 localstorage ？ 优点 ：全自动 三、 补充信息 1. 解构 和 reactive 一样，直接解构会使数据失去响应式 不同于 vue 的 toRef()，对于 pinia， 需要使用 storeToRefs() import { storeToRefs } from &quot;pinia&quot;; 2. Setup Store 1.2 中定义的方法官方称为 Setup Store 在 Setup Store 中： ref() 就是 state 属性 computed() 就是 getters function() 就是 actions 3. state getters actions 的解释 state 在大多数情况下，state 都是你的 store 的核心。人们通常会先定义能代表他们 APP 的 state。在 Pinia 中，state 被定义为一个返回初始状态的函数。这使得 Pinia 可以同时支持服务端和客户端。 state 里面写的是初始值 getters Getter 完全等同于 store 的 state 的计算值。可以通过 defineStore() 中的 getters 属性来定义它们。推荐使用箭头函数 相当于 computed() Action Action 相当于组件中的 method。它们可以通过 defineStore() 中的 actions 属性来定义，并且它们也是定义业务逻辑的完美选择。 是普通的函数 ","link":"https://blog.xn--fiqz59cpva341l.top/post/zai-vue-zhong-shi-yong-pinia/"},{"title":"HTML5里的 localStorage 和 sessionStorage","content":"同源网页的储物箱 localStorage 本地储存，使用起来是一个类似字典（dict）的东西？ 作用域: 一般是同源，其他不同域名网页无法访问 大小: 一般是 5M 生命周期: 永久，除非手动删除 // 查看所有 localStorage; // 清空 localStorage.clear(); // 添加项目 localStorage.setItem(&quot;name&quot;, &quot;张三&quot;); localStorage.name = &quot;张三&quot;; // 获取值 localStorage.getItem(&quot;name&quot;); // 删除项目 localStorage.removeItem(&quot;name&quot;); 测试网页 sessionStorage 会话存储，与 localStorage 用法几乎一样，但有一些区别 作用域: 同源，其他不同域名网页无法访问 大小: 一般是 5M 生命周期: 仅在当前会话期间，关闭浏览器标签或窗口后会被清除 // 查看所有 sessionStorage; // 清空 sessionStorage.clear(); // 添加项目 sessionStorage.setItem(&quot;name&quot;, &quot;张三&quot;); sessionStorage.name = &quot;张三&quot;; // 获取值 sessionStorage.getItem(&quot;name&quot;); // 删除项目 sessionStorage.removeItem(&quot;name&quot;); ","link":"https://blog.xn--fiqz59cpva341l.top/post/html5-li-de-localstorage-he-sessionstorage/"},{"title":"Vue 相关笔记","content":"记录一些 Vue 知识 常用标签属性 v-text 和 v-html v-text 相当于 innerText 但是响应式 一般不用 直接 {{ text }} v-html 相当于 innerHtml 但是响应式 v-show 和 v-if 区别，一个是隐藏，一个是小消失 v-show 根据值的真假，是否显示组件 v-if 根据值的真假，是否渲染组件 v-else 和 v-else-if 不好说，借来官网示例理解 v-else &lt;div v-if=&quot;Math.random() &gt; 0.5&quot;&gt;Now you see me&lt;/div&gt; &lt;div v-else&gt;Now you don't&lt;/div&gt; v-else-if &lt;div v-if=&quot;type === 'A'&quot;&gt;A&lt;/div&gt; &lt;div v-else-if=&quot;type === 'B'&quot;&gt;B&lt;/div&gt; &lt;div v-else-if=&quot;type === 'C'&quot;&gt;C&lt;/div&gt; &lt;div v-else&gt;Not A/B/C&lt;/div&gt; v-for 动态生成多个模板元素 &lt;div v-for=&quot;item in items&quot;&gt;{{ item.text }}&lt;/div&gt; &lt;div v-for=&quot;(item, index) in items&quot;&gt;&lt;/div&gt; &lt;div v-for=&quot;(value, key) in object&quot;&gt;&lt;/div&gt; &lt;div v-for=&quot;(value, name, index) in object&quot;&gt;&lt;/div&gt; v-on 类似 onclick addEventerListener 等 可以简写为@ &lt;button @click=&quot;要执行的函数或代码&quot;&gt;按钮&lt;/button&gt; 可以便捷的阻止事件冒泡通 过加入 .prevent .stop 来代替 event.preventDefault() 或 event.stopPropagation() &lt;a @click.stop=&quot;doThis&quot;&gt;&lt;/a&gt; &lt;form @submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt; &lt;a @click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt; v-bind 和 v-model 使用在元素属性中（区别于 {{ }} ）的数据绑定 v-bind 数据单向绑定 (简写为 :attr=&quot;varF&quot;) &lt;a :herf=&quot;url&quot;&gt;{{ url }}&lt;/a&gt; v-model 数据双向绑定，通常用于表单元素 （代替 value 属性？） &lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot; /&gt; &lt;p&gt;Message is: {{ message }}&lt;/p&gt; 仅限： &lt;input&gt; &lt;select&gt; &lt;textarea&gt; components 修饰符 .lazy - 监听 change 事件而不是 input .number - 将输入的合法字符串转为数字 .trim - 移除输入内容两端空格 v-slot 插槽相关，用于指定插槽名字 &lt;template v-slot:slotname&gt; &lt;/template&gt; 可以缩写 &lt;template #slotname&gt; &lt;/template&gt; 其他 父组件到子组件的传参 通过 provide 传出 inject 接收 父组件 import { provide } from &quot;vue&quot;; var a = ref(0); var b = () =&gt; { console.log(1); }; // 支持变量和函数 provide(&quot;provide_a&quot;, a); provide(&quot;provide_fun_b&quot;, b); 子组件 import { inject } from &quot;vue&quot;; var a = inject(&quot;provide_a&quot;); var b = inject(&quot;provide_fun_b&quot;); 匿名插槽 和 具名插槽 普通自闭合标签 &lt;Com2 /&gt; 匿名插槽 &lt;Com2&gt; &lt;div&gt;插进来了&lt;/div&gt; &lt;/Com2&gt; 具名插槽，需要指定名称，有两个写法 &lt;Com2&gt; &lt;template v-slot=slotProps&gt; &lt;div&gt;写法 1&lt;/div&gt; &lt;/template&gt; &lt;template #slotProps&gt; &lt;div&gt;写法 2&lt;/div&gt; &lt;/template&gt; &lt;/Com2&gt; com2.vue 两 slot 同时写的话根据传入的插槽类型自动选择生效 &lt;template&gt; &lt;div&gt;组件 2 开始&lt;/div&gt; &lt;slot /&gt; &lt;slot name=&quot;slotProps&quot; /&gt; &lt;div&gt;组件 2 结束&lt;/div&gt; &lt;/template&gt; 子组件到父组件的传参 父组件 &lt;template&gt; &lt;Com2 #slotProps=&quot;data&quot;&gt; &lt;div&gt;{{ `${data.apple} + ${data.paper}` }}&lt;/div&gt; &lt;/Com2&gt; &lt;/template&gt; 子组件 &lt;template&gt; &lt;div&gt;组件 2 开始&lt;/div&gt; &lt;slot name=&quot;slotProps&quot; apple=&quot;apple&quot; paper=&quot;paper&quot; /&gt; &lt;div&gt;组件 2 结束&lt;/div&gt; &lt;/template&gt; ## 生命周期函数 一些 on 开头的函数 父组件 &lt;template&gt; &lt;Div2 v-if=&quot;show&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;切换&quot; @click=&quot;delete_div&quot;&gt; &lt;/template&gt; &lt;script setup&gt; import Div2 from './components/2.vue' import { ref } from 'vue' var show = ref(true); var delete_div = () =&gt; { show.value = !show.value; } &lt;/script&gt; v-if 不仅仅控制元素的可见性 它还会根据条件动态地创建或销毁 DOM 元素 因此可以用来测试挂载和卸载组件 子组件 2.vue &lt;template&gt; num: {{ num }} &lt;input type=&quot;button&quot; value=&quot;添加&quot; @click=&quot;add&quot;&gt; &lt;/template&gt; &lt;script setup&gt; import { ref, onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted, } from &quot;vue&quot;; var add = () =&gt; { num.value++; }; var num = ref(0); onBeforeMount(() =&gt; { console.log(&quot;[挂载] 组件 1 挂载前&quot;); }); onMounted(() =&gt; { console.log(&quot;[挂载] 组件 1 挂载&quot;); }); onBeforeUpdate(() =&gt; { console.log(&quot;[更新] 组件 1 更新前&quot;); }); onUpdated(() =&gt; { console.log(&quot;[更新] 组件 1 更新&quot;); }); onBeforeUnmount(() =&gt; { console.log(&quot;[卸载] 组件 1 卸载前&quot;); }); onUnmounted(() =&gt; { console.log(&quot;[卸载] 组件 1 卸载&quot;); }); &lt;/script&gt; toref 和 torefs 用于将响应式数据转换为 ref。 import { reactive, toRef, toRefs } from &quot;vue&quot;; const state = reactive({ count: 0, }); const state = reactive({ count: 0, name: &quot;Vue&quot;, }); const count = toRef(state, &quot;count&quot;); const { count, name } = toRefs(state); ","link":"https://blog.xn--fiqz59cpva341l.top/post/vue-xiang-guan-bi-ji/"},{"title":"大数据疑难解决","content":"记录一些实战遇到的问题和解决办法 NoNode for /hbase/hbaseid 运行hbase shell出现类似报错， 解决办法 修改hbase-env.sh，为该文件增加 export HBASE_DISABLE_HADOOP_CLASSPATH_LOOKUP=&quot;true&quot; 运行出现 entry in command string: null chmod 0700 异常解决方案 去 https://github.com/cdarlint/winutils 随便找个近似版本,下载里面的 hadoop.dll 和 winutils.exe 添加 hadoop.dll 和 winutils.exe 到 windows 的环境变量比如放到 hadoop/bin 里 no hbase master found hbase 启动失败，idea 里面操作无报错无返回 查看日志 2024-04-24T09:40:45,557 ERROR [main] regionserver.HRegionServer: Failed construction RegionServer java.io.IOException: Incomplete HDFS URI, no host: hdfs://master:8020:hbase 2024-04-24T09:40:45,562 ERROR [main] master.HMasterCommandLine: Master exiting java.lang.RuntimeException: Failed construction of Master: class org.apache.hadoop.hbase.master.HMaster. ... Caused by: java.io.IOException: Incomplete HDFS URI, no host: hdfs://master:8020/hbase ... 但 hdfs://master/8020 可达 谁知 hbase 竟然需要 hadoop 的版本支持 可见网址 https://hbase.apache.org/book.html#hadoop 我的 hbase 版本是 hadoop 所不支持的，自然不能运行 &lt;hadoop.version&gt;2.7.5&lt;/hadoop.version&gt; &lt;hbase.version&gt;2.5.8&lt;/hbase.version&gt; 官网可不提供旧版的下载，不过还好提供了 archive https://archive.apache.org/dist/hbase/ Hadoop-2.7.1+ 对应得是 HBase-1.4.x，直接选择最新版 https://archive.apache.org/dist/hbase/1.4.14/hbase-1.4.14-bin.tar.gz Master is initializing HTTP ERROR 500 Problem accessing /master-status. Reason: Master is initializing /opt/zookeeper/bin/zkCli.sh ls / http://master:50070/ 2024-04-24 10:57:11,397 INFO [master/master/192.168.29.20:16000-SendThread(master:2181)] zookeeper.ClientCnxn: Opening socket connection to server master/192.168.29.20:2181. Will not attempt to authenticate using SASL (unknown error) 2024-04-24 10:57:25,981 WARN [933646237@qtp-1397530667-0] mortbay.log: /master-status: org.apache.hadoop.hbase.PleaseHoldException: Master is initializing 2024-04-24 10:54:19,310 [myid:] - WARN [QuorumConnectionThread-[myid=2]-2:o.a.z.s.q.QuorumCnxManager@401] - Cannot open channel to 3 at election address slave2/192.168.29.22:3888 java.net.ConnectException: 拒绝连接 (Connection refused) at java.net.PlainSocketImpl.socketConnect(Native Method) at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:476) at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:218) at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:200) at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:394) at java.net.Socket.connect(Socket.java:606) at org.apache.zookeeper.server.quorum.QuorumCnxManager.initiateConnection(QuorumCnxManager.java:384) at org.apache.zookeeper.server.quorum.QuorumCnxManagerQuorumConnectionReqThread.run(QuorumCnxManager.java:458)atjava.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)atjava.util.concurrent.ThreadPoolExecutorQuorumConnectionReqThread.run(QuorumCnxManager.java:458) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutorQuorumConnectionReqThread.run(QuorumCnxManager.java:458)atjava.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)atjava.util.concurrent.ThreadPoolExecutorWorker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:750) ","link":"https://blog.xn--fiqz59cpva341l.top/post/da-shu-ju-wen-ti-ji-lu/"},{"title":"Hadoop 2 与 3 在配置环境时的区别","content":"区别不是很多（在环境配置方面） 一、hdfs 网页面板 从 hadoop 3 开始 master:50070 更为 master:9870 master 为主机的主机名 一、slaves文件 从 hadoop 3 开始 slaves 文件更名为 workers 为反对种族歧视，几乎各大知名项目都有类似行为 比如 Github 分支名 master 改为 main 其他方面目前没有发现 ","link":"https://blog.xn--fiqz59cpva341l.top/post/hadoop-2-yu-3-zai-pei-zhi-huan-jing-shi-de-qu-bie/"},{"title":"Python 创建虚拟环境","content":"每次要用就想不起来命令，写个记录下 Q: 你玩 MC 为什么要开 版本隔离 ？（为什么要用虚拟环境？） A: 防止多个游戏版本的模块相互冲突，方便管理 一、 python 自带 venv 库 1. 创建虚拟环境 python -m venv .venv 指定版本 把 python 改为 指定 python.exe 的路径 命令参数用法 usage：venv [-h] [--system-site-packages] [--symlinks | --copies] [--clear] [--upgrade] [--without-pip] [--prompt PROMPT] [--upgrade-deps] ENV_DIR [ENV_DIR ...] 在一个或多个目标目录中创建虚拟 Python 环境。 位置参数： ENV_DIR 要在其中创建环境的目录。 可选参数： -h, --help 显示帮助消息并退出 --clear 在创建环境之前删除环境目录的内容，如果它已经存在。 --upgrade 升级环境目录以使用 Python 的此版本，假设 Python 已经在原地升级。 --without-pip 跳过在虚拟环境中安装或升级 pip（pip 默认情况下是引导的）。 --prompt PROMPT 为此环境提供替代提示前缀。 --upgrade-deps 升级核心依赖项：pip 和 setuptools 到 PyPI 中的最新版本。 一旦环境被创建，您可能希望激活它，例如通过在其 bin 目录中运行激活脚本。 2. 激活虚拟环境 # 在 Windows 上 .venv\\Scripts\\activate .venv\\Scripts\\activate.bat .venv\\Scripts\\activate.ps1 # 在 linux 等系统上 source .venv/bin/activate 3. 退出虚拟环境 deactivate 3. 删除虚拟环境 删除 .venv 文件即可 二、virtualenv 注意： 需要安装 需要 Python 3.7+ 1. 安装 pip install virtualenv 创建环境（在当前目录中创建文件夹） virtualenv .venv # 指定py版本 virtualenv .venv -p=Python3.11.7 2. 激活与删除 同 一、2. 激活虚拟环境 不多介绍 ","link":"https://blog.xn--fiqz59cpva341l.top/post/python-chuang-jian-xu-ni-huan-jing/"},{"title":"Rust 基础","content":"今天开始学rust 一、变量 1. let 不变的变量 let 是不可变的 let variable_name = value; 示例： let x = 5; println!(&quot;The value of x is: {}&quot;, x); // x = 6; // 这行会引起编译错误，因为x是不可变的 2. let mut 会变得变量 mut 关键字来声明变量是可变的 let mut variable_name = value; 示例： let mut y = 5; println!(&quot;The value of y is: {}&quot;, y); y = 10; // 正确，因为y是可变的 println!(&quot;The value of y is now: {}&quot;, y); 3. const 这次是真的常量 const 关键字用于声明一个常量常量类似于不可变变量，但有几个关键区别： 常量不仅不可变，而且必须在编译时就已知其值 常量可以在任何作用域内声明，包括全局作用域 常量遵循与静态生命周期一致的规则，即它们的值始终存在 示例： const MAX_POINTS: u32 = 100_000; // 一般const就像这样全大写 println!(&quot;The maximum points are: {}&quot;, MAX_POINTS); 二、Rust 中的数据类型 Rust 中的数据类型主要分为两大类 标量类型和复合类型 在创建变量时指定类型 let a = '2'; let b: char = '2'; 这两一样的 const 必须声明类型 1. 标量类型 标量类型代表单一值Rust 有四种基本的标量类型：整数、浮点数、布尔值和字符 A. 整数类型： 有符号整数（i8, i16, i32, i64, i128, isize）和无符号整数（u8, u16, u32, u64, u128, usize） B. 浮点类型： f32：32 位浮点数 f64：64 位浮点数（默认） C. 布尔类型： bool：它有两个可能的值：true 和 false D. 字符类型： char：表示单个 Unicode 标量值（比如一个字母或数字），存储为 4 个字节 字符串属于什么？ Answer: 在 Rust 中，字符串主要以两种形式出现：String 和字符串切片 &amp;str。 String 类型： String 是一个可增长、可缩短、可变、拥有所有权的 UTF-8 编码字符串类型。 它在堆上分配空间，因此可以存储在编译时未知大小的文本。 字符串切片 &amp;str 类型： &amp;str 是一个不可变的字符串切片，通常以字符串字面量的形式出现。 字符串切片是固定大小的，不能被增长或缩短。 示例： let d = &quot;Hello&quot;; println!(&quot;{d} world!&quot;); let e = String::from(&quot;hello&quot;); println!(&quot;{e} world!&quot;); 这两种字符串类型之间的主要区别在于所有权。String 是一个拥有所有权的类型，可以被修改和增长；而 &amp;str 是一个借用类型，通常用于借用字符串的一部分。 2. 复合类型 复合类型可以将多个值组合成一个类型Rust 有两个主要的复合类型：元组（tuple）和数组（array） A. 元组类型： 长度固定 类型可以不同 let a = (1, 2, 3, 4); // 创建一个元组 let (b, c, d, e) = a; println!(&quot;{}{}{}{}&quot;, b, c, d, e); // 解构元组 println!(&quot;{}&quot;, a.0); // 下标访问元组元素 B. 数组类型： 类型相同 长度固定 数组在栈上分配，而不是在堆上 let x = [1,2,3]; // 创建一个数组 let [a,b,c] = x; println!(&quot;{a}{b}{c}&quot;); // 解构数组 println!(&quot;{}&quot;, x[1]); // 下标访问数组元素 3. 类型转换 总结 字符串 to 其他: let b: bool = a.parse().expect(&quot;Not bool&quot;); 其他 to 字符串: let b: String = a.to_string(); 其他 to 其他: let b = a as i32; ","link":"https://blog.xn--fiqz59cpva341l.top/post/rust-ji-chu/"},{"title":"Rust 从安装到卸载","content":"一、（在WIN）安装 来到官网https://www.rust-lang.org/zh-CN/tools/install 选择下载rustup-init.exe (64位) 或者直接直链下载 打开文件目录 一路按照指示安装即可（会自动帮你安装VS） 安装缓慢可以使用国内源来安装 以下在powershell运行 $ENV:RUSTUP_DIST_SERVER='https://mirrors.ustc.edu.cn/rust-static' $ENV:RUSTUP_UPDATE_ROOT='https://mirrors.ustc.edu.cn/rust-static/rustup' .\\rustup-init.exe 不安装VS的方法： 下载Microsoft C++ 生成工具 官网链接 点击下载生成工具 点击安装 过程中选择使用 C++ 的桌面开发打勾 一路继续即可 二、 卸载 终端输入 rustup self uninstall 三、基本命令 rustc rustc -V # 查看rust版本 rustc rs文件 # 编译rs文件 rustup rustup update # 更新 rustup self uninstall # 卸载 Rust 和 rustup cargo cargo new 项目名称 # 创建新项目 cargo build # 编译 cargo run # 编译并运行 cargo clean # 清理临时文件 ","link":"https://blog.xn--fiqz59cpva341l.top/post/rust-cong-an-zhuang-dao-xie-zai/"},{"title":"为 Git 添加代理避免同步网络错误","content":"问题提出 单单在代理软件中开启系统代理并不能解决git同步失败的问题，只有开启TUN模式才能，但这样的方式容易影响其他软件， 因此，有必要为git单独设置代理 问题解决 在 git 中配置单独的代理设置，下面是 clash 的示例 git config --global http.proxy 'http://127.0.0.1:7890' git config --global https.proxy 'https://127.0.0.1:7890' ","link":"https://blog.xn--fiqz59cpva341l.top/post/wei-git-tian-jia-dai-li-bi-mian-tong-bu-wang-luo-cuo-wu/"},{"title":"在纯静态网页中使用Monaco Editor","content":"Monaco Editor 项目地址： [Monaco Editor](https: //microsoft.github.io/monaco-editor/) 示例HTML &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;!-- 导入模块 --&gt; &lt;script src=&quot;https: //cdn.staticfile.org/monaco-editor/0.19.3/min/vs/loader.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; require.config({ paths: { 'vs': 'https: //cdn.staticfile.org/monaco-editor/0.19.3/min/vs' } }); require(['vs/editor/editor.main'], function () { // 启动 init_edit( `function init_edit(value) { window.monaco.editor.create( document.getElementById(&quot;container&quot;), { value, }) }` ) }); function init_edit(value) { window.monaco.editor.create( // 显示在哪 document.getElementById(&quot;container&quot;), { // 显示什么 value, }) } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;container&quot; style=&quot;height: 500px&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 配置项详解 一些写在create()里的基本配置项 const option = { value: '', // 编辑器创建时初始显示文字 language: 'sql', // 高亮语言 automaticLayout: true, // 自适应宽高 foldingStrategy: 'indentation', // 代码可分小段折叠 autoClosingBrackets: 'always', // 是否自动添加结束括号(包括中括号) &quot;always&quot; | &quot;languageDefined&quot; | &quot;beforeWhitespace&quot; | &quot;never&quot; autoClosingDelete: 'always', // 是否自动删除结束括号(包括中括号) &quot;always&quot; | &quot;never&quot; | &quot;auto&quot; autoClosingQuotes: 'always', // 是否自动添加结束的单引号 双引号 &quot;always&quot; | &quot;languageDefined&quot; | &quot;beforeWhitespace&quot; | &quot;never&quot; autoIndent: 'None', // 控制编辑器在用户键入、粘贴、移动或缩进行时是否应自动调整缩进 comments: { ignoreEmptyLines: true, // 插入行注释时忽略空行。默认为真。 insertSpace: true // 在行注释标记之后和块注释标记内插入一个空格。默认为真。 }, cursorBlinking: 'Solid', // 光标动画样式 cursorSmoothCaretAnimation: true, // 是否启用光标平滑插入动画 当你在快速输入文字的时候 光标是直接平滑的移动还是直接&quot;闪现&quot;到当前文字所处位置 cursorSurroundingLines: 0, // 光标环绕行数 当文字输入超过屏幕时 可以看见右侧滚动条中光标所处位置是在滚动条中间还是顶部还是底部 即光标环绕行数 环绕行数越大 光标在滚动条中位置越居中 cursorSurroundingLinesStyle: 'all', // &quot;default&quot; | &quot;all&quot; 光标环绕样式 cursorWidth: 2, // &lt;=25 光标宽度 minimap: { // 关闭代码缩略图 enabled: false // 是否启用预览图 }, overviewRulerBorder: false, // 是否应围绕概览标尺绘制边框 folding: true, // 是否启用代码折叠 scrollBeyondLastLine: false, // 设置编辑器是否可以滚动到最后一行之后 renderLineHighlight: 'all', // 当前行突出显示方式 &quot;all&quot; | &quot;line&quot; | &quot;none&quot; | &quot;gutter&quot; theme: 'vs' // 官方自带三种主题vs, hc-black, or vs-dark } ","link":"https://blog.xn--fiqz59cpva341l.top/post/zai-chun-jing-tai-wang-ye-zhong-shi-yong/"},{"title":"node.js 文件读写的简单代码","content":"更详细的的文档说明 https://nodejs.cn/api/fs.html 一、使用 fs 模块 读取文件 读取文本 var fs = require('fs') fs.readFile('js/2.js','utf-8', function (err, data) { if (err) { console.log(err) } else { console.log(data) } }) var fs = require('fs') 导入文件读写模块fs并存入变量fs readFile(文件,编码,回调函数) 读取文件的方法，需要三个参 编码为必须，不写默认为二进制读取 function (err, data) 回调函数，err 错误信息 data 读取的数据 没有错误err为bull 可以优化为箭头函数 fs.readFile('js/2.js', 'utf-8', (err, data) =&gt; { if (err) { console.log(err) } else { console.log('读取好了' + data) } }) 读取二进制数据 fs.readFile('js/2.js', function (err, data) { if (err) { console.log(err) } else { console.log(data) } }) 由于没有传入编码，所以编码默认为null 读取返回的是例如下面的二进制数据 Buffer(158) [102, 117, 110, '...'] 写入数据 fs.writeFile('js/2.js', data, function (err) { if (err) { console.log(err) } else { console.log('写好了') } }) writeFile(文件,数据,回调函数) 写入数据的方法 同步 以上操作默认为异步，如果需要同步 fs.readFileSync() fs.writeFileSync() 二、使用 fs 的 stream 1. 为什么要使用？ readFile 是一口气吃完整个文件再给你 createReadStream 是一口一口吃一口一口咽 除非文件很大（如大于1M的图片音乐等），不使用createReadStream fs.createReadStream 更适合处理大文件。 fs.createReadStream 创建一个读取文件的流，并且可以逐块读取和发送文件(data事件可能会有多次，每次传递的chunk是流的一部分数据。)，而不需要一次性将整个文件加载到内存中。这使得 fs.createReadStream 能够处理非常大的文件，而不会消耗过多的内存。 相比之下，fs.readFile 会一次性将整个文件读入内存，如果文件非常大，这可能会消耗大量的内存，并可能导致 Node.js 进程崩溃。 读取流中每个区块的大小 创建一个读取流时，你可以指定一个选项 highWaterMark 来控制每次读取的数据块的大小。highWaterMark 的默认值是 64KB（对于 fs 模块）。 读取文件 基本示例： const fs = require('fs') // 怎么读，读什么 var rs = fs.createReadStream('2.js', 'utf-8') // 在读了 rs.on('data', function (chunk) { console.log(chunk); }); // 读完了 rs.on('end', function () { console.log('END'); }); // 读不了 rs.on('error', function (err) { console.log('ERROR: ' + err); }); 写入文件 基本示例： const fs = require('fs') // 如果文件没有会创建 var rs = fs.createWriteStream('2.js', 'utf-8') rs.on('finish', () =&gt; { // 成功事件（在end()后） console.log(&quot;finish&quot;) }).on('error', (e) =&gt; { // 异常事件 console.log(&quot;error!&quot; + e) }) // 途中多次write会追加写入 rs.write(&quot;你好&quot;) rs.write(&quot;\\n&quot;) rs.write(&quot;Magic Node.js&quot;) // 结束写入 rs.end() ","link":"https://blog.xn--fiqz59cpva341l.top/post/nodejs-du-qu-wen-jian-de-dai-ma-fen-xi/"},{"title":"Python 爬虫入门","content":"记录一下目前会的爬虫知识 一、Requests 库 安装与导入 安装 pip install requests 导入模块 import requests 方法 请求类型 get post put delete head options 示例（get请求） r = requests.get( url=&quot;&quot;, headers={}, cookies=&quot;&quot;, data={} ) 示例（post请求） payload = dict(key1='value1', key2='value2') r = requests.post('https://httpbin.org/post', data=payload) 输入 参数 类型 介绍 url str 网站 params 携带的参数 headers cookies timeout 不指定了 timeout 值，requests 不会自动进行超时处理 输出 方法返回为一个类型为Response(requests.Response)的对象 下面是一些常用的方法 apparent_encoding() 自动猜测网页编码 encoding(str) 指定网页编码，需要传入一个字符串参数 text() 返回网页内容 raise_for_status() 网页状态码是4或5开头时（如404），自动抛出异常 content() 以二进制的形式返回网页内容（常用于非文本内容的保存如图片） 保存图片示例 with open('test.png','wb') as f: f.write(requests.get( url=&quot;&quot; )) status_code() 返回网页状态码 二、BeautifulSoup 库 BeautifulSoup是一个Python库，用于从HTML和XML文件中提取数据。它提供了一种简单的方式来遍历HTML和XML文档的树形结构，并从中提取所需的数据。BeautifulSoup可以处理不规则的标记和嵌套标记，使得数据提取变得更加容易。 官方文档：点击查看 安装与导入 安装 pip install beautifulsoup4 导入 from bs4 import BeautifulSoup 初始化bs4对象 BeautifulSoup() 这样用 soup = BeautifulSoup( markup=&quot;&quot;, builder=&quot;&quot; ) 参数说明 参数 说明 示例 markup 网页 &quot;str网页内容&quot;或open(&quot;1.html&quot;)或requests.get(&quot;&quot;).text builder 解析器 html.parser 或 lxml 对象属性的访问与修改 tag的属性操作方法与字典一样！ # 示例HTML soup = BeautifulSoup('&lt;b class=&quot;boldest&quot;&gt;Extremely bold&lt;/b&gt;') # 访问元素 soup.b &lt;b class=&quot;boldest&quot;&gt;Extremely bold&lt;/b&gt; # 属性修改与访问 soup.b[&quot;class&quot;] = &quot;new_boldest&quot; soup.b[&quot;class&quot;] ['new_boldest'] 取出文字 soup.b.text # 不需要括号 查找元素 1. find()和find_all() 标题对应: 返回查找到的元素的第一个 与 返回查找到的元素的列表 例子： # 查找 标签是p 的元素 soup.find_all(&quot;p&quot;) # 查找 标签是p、CSS类名title的元素 soup.find_all(&quot;p&quot;, &quot;link2&quot;) # 查找 包含id属性 的元素 soup.find_all(id=True) # 查找 id=link2 的元素 soup.find_all(id=&quot;link2&quot;) # 查找 标签是p、id=link2 的元素 soup.find_all(&quot;p&quot;, id=&quot;link2&quot;) 2. select_one()和select() 标题对应: 返回查找到的元素的第一个 与 返回查找到的元素的列表 通过在.select() 方法中传入字符串参数, 即可使用CSS选择器的语法查找 例子： soup.select(&quot;p &gt; a:nth-of-type(2)&quot;) # [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;] soup.select(&quot;p &gt; #link1&quot;) # [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;] 三、lxml 库（Xpath） lxml是Python中一个非常流行的XML和HTML处理库，它提供了一个XPath解析器，可以使用XPath表达式来查找和提取XML和HTML文档中的数据。 XPath是一种用于在XML和HTML文档中定位元素和属性的语言。XPath表达式可以用于选择文档中的特定元素或属性，或者从文档中提取特定的数据。 安装与导入 安装 pip install lxml 导入 from lxml import etree 初始化XPath解析对象 lxml 支持XPath语法 html=etree.HTML(网页) 通过XPath查找 html.xpath('xpath表达式') 返回的一定是一个列表！ 如何快速获取XPath表达式： 浏览器开发者工具-元素 右键目标元素 - 复制 - 复制XPath XPath语法 选择元素：使用元素名称选择元素，例如：&lt;book&gt; 选择所有 &lt;book&gt; 元素。 选择属性：使用 @ 符号选择属性，例如：@id 选择所有 id 属性。 路径表达式：使用 / 符号表示从根节点开始的路径，例如：/bookstore/book 选择所有根节点为 bookstore 的子节点 book。 选择子元素：使用 / 符号选择子元素，例如：bookstore/book/title 选择所有 bookstore 元素下的 book 元素下的 title 元素。 选择父元素：使用 .. 符号选择父元素，例如：bookstore/book/.. 选择所有 bookstore 元素下的 book 元素的父元素。 选择当前元素：使用 . 符号选择当前元素，例如：bookstore/book/./title 选择所有 bookstore 元素下的 book 元素下的当前元素 title 元素。 选择多个元素：使用|符号选择多个元素，例如：//book | //cd 选择所有 book 和 cd 元素。 选择具有特定属性值的元素：使用 [@attribute='value'] 选择具有特定属性值的元素，例如：//book[@category='children'] 选择所有 category 属性为 children 的 book 元素。 选择具有特定文本值的元素：使用 [text()='value'] 选择具有特定文本值的元素，例如：//title[text()='Harry Potter'] 选择所有文本值为 Harry Potter 的 title 元素。 选择具有特定位置的元素：使用 [position()='value'] 选择具有特定位置的元素，例如：//book[position()=1] 选择第一个 book 元素。 以上由GPT生成 四、Scrapy Scrapy是一个用于爬取网站数据的Python框架。它提供了一种简单而强大的方式来定义爬取网站的方式，并且可以自动化地处理从网站中提取的数据。Scrapy框架包括了一些核心组件，如爬虫引擎、调度器、下载器、管道等，这些组件可以协同工作，使得爬虫的开发和维护变得更加容易。 安装与准备 安装 pip install scrapy 验证是否安装成功 在终端输入scrapy,结果如下 &gt; scrapy Scrapy 2.11.0 - no active project Usage: scrapy &lt;command&gt; [options] [args] Available commands: bench Run quick benchmark test fetch Fetch a URL using the Scrapy downloader genspider Generate new spider using pre-defined templates runspider Run a self-contained spider (without creating a project) settings Get settings values shell Interactive scraping console startproject Create new project version Print Scrapy version view Open URL in browser, as seen by Scrapy [ more ] More commands available when run from project directory Use &quot;scrapy &lt;command&gt; -h&quot; to see more info about a command 基本命令 命令 说明 示例 startproject 创建一个scrapy项目 scrapy startproject myproject genspider 创建一个爬虫（在项目下） scrapy genspider myspider example.com(目标网址) runspider 运行这个爬虫 scrapy runspider myspider.py 其他 学习scrapy没什么意思，用处也不大，更多是作为教学工具，我就不往下写了 五、Selenium Selenium是一个用于自动化Web应用程序测试的强大工具。它提供了一个用于模拟用户在浏览器中操作的框架，可以用于测试Web应用程序的功能性和性能。 导入包 pip install selenium 下载浏览器驱动 edge https://msedgewebdriverstorage.z22.web.core.windows.net Chrome https://chromedriver.storage.googleapis.com/index.html Firefox https://github.com/mozilla/geckodriver/releases Opera https://github.com/operasoftware/operachromiumdriver/releases 下载符合自己浏览器的驱动（360搜狗什么国产浏览器就不要爬了） 驱动配置 两种方式选择其一 添加到系统的Path目录 在python代码中声明驱动路径 webdriver.Chrome(executable_path='驱动目录') 待写。。。 ","link":"https://blog.xn--fiqz59cpva341l.top/post/python-pa-chong-ru-men/"},{"title":"MongoDB 与 Python Mongodb","content":"本文章在windows环境，不探讨MongoDB Shell命令 1. 安装MongoDB 这个官方DOC https://www.mongodb.com/docs/manual/introduction/ 下载地址 https://www.mongodb.com/try/download/community 选择msi后缀的版本下载 直接无脑安装 2. 安装Mongosh MongoDB Shell（mongosh）未与MongoDB服务器一同安装。你需要按照mongosh的安装说明单独下载和安装mongosh(点击查看)。 下载完成后解压放入一个目录，例如C盘下，添加环境变量，记得加上\\bin例如 C:\\mongosh-2.0.1-win32-x64\\bin 在终端输入 mongosh测试是否成功进入shell 在Navicat可视化查看: 直接添加连接，选择MongoDB，信息默认就行（如果没改） 3. Python中的使用 3.1. 安装包 pip install pymongo 3.2. 连接数据库的2方法 from pymongo.mongo_client import MongoClient # 使用默认本地主机和端口（27017）创建连接 client = MongoClient('localhost', 27017) # 或者，使用连接字符串连接到 MongoDB s = &quot;mongodb://127.0.0.1:27017/?directConnection=true&amp;serverSelectionTimeoutMS=2000&amp;appName=mongosh+2.0.1&quot; client = MongoClient(s) s 这字符串在哪获得？终端中进入mongosh时会显示，在Connecting to:后面 3.3. 创建数据库和集合 集合相当于表 # 创建数据库 mydb = client[&quot;my1stdb&quot;] # 创建表 mytable = mydb[&quot;class&quot;] 此时数据库和集合还没真正创建，因为数据库和表是空的 3.4. 显示数据库、集合和数据 显示数据库、集合 print( client.list_database_names(), # 显示数据库列表 mydb.list_collection_names() # 显示集合列表 ) 显示集合内容 records = mytable.find() for record in records: print(record) # 不能直接打印 records 此时看不到，完成 3.5 才能看到 3.5. 添加数据 添加单个记录 mytable.insert_one( # 输入是一个字典 {&quot;name&quot;: &quot;xiaohei&quot;, &quot;age&quot;: &quot;18&quot;} ) 添加多个记录 mytable.insert_many( # 输入时一个字典列表 [{&quot;name&quot;: &quot;xiaohong&quot;, &quot;age&quot;: &quot;18&quot;}, {&quot;name&quot;: &quot;xiaolan&quot;, &quot;age&quot;: &quot;18&quot;}] ) 3.6. 删除集合和数据和数据库 删除一个（符合条件的第一个） mytable.delete_one( {&quot;name&quot;: &quot;xiaohong&quot;} ) 删除全部 mytable.delete_many({}) 删除多个（所有符合条件的） mytable.delete_many( {&quot;name&quot;: &quot;xiaohong&quot;, &quot;age&quot;: &quot;18&quot;} ) # 传入的是一个字典，不是列表 # 可以使用正则表达式 mytable.delete_many( {&quot;name&quot;: {&quot;$regex&quot;: &quot;^xiao&quot;}} # 删除所有xiao开头的数据 ) 删除集合 mydb = client[&quot;my1stdb&quot;] mytable = mydb[&quot;class1&quot;] # 第一种 mydb.drop_collection(&quot;class1&quot;) # 第二种 mytable.drop() 删除数据库 # 第一种 client.drop_database(&quot;xxx&quot;) # 第二种 mytable.drop() 3.6. 修改数据 如下面格式 # mytable.update_one( # {&quot;查找&quot;}, # {&quot;$set&quot;: &quot;改成什么&quot;} # ) mytable.update_one( {&quot;name&quot;: &quot;xiaolan&quot;}, {&quot;$set&quot;: {&quot;name&quot;: &quot;xiaobai&quot;}} ) mytable.update_many( {&quot;name&quot;: &quot;xiaohong&quot;}, {&quot;$set&quot;: {&quot;name&quot;: &quot;xiaolan&quot;}} ) 3.7. 查询数据 查找一个 x = mytable.find_one( {&quot;age&quot;: &quot;14&quot;} ) # {'_id': ObjectId('65297cce8b9a13e50784fe86'), 'name': 'xiaolu', 'age': '14'} 查找多个 x = mytable.find( {&quot;age&quot;: &quot;14&quot;} ) # {'_id': ObjectId('65297d04b06c5d3a99ddc75b'), 'name': 'xiaolu', 'age': '14'} # {'_id': ObjectId('65297d04b06c5d3a99ddc75d'), 'name': 'xiaolan', 'age': '14'} 自定义查找返回的结果 0为隐藏，1为显示，_id 默认为 1 x = mytable.find( {}, {&quot;_id&quot;: 0, &quot;name&quot;:1,&quot;age&quot;: 1} ) # {'name': 'xiaohong', 'age': '18'} # {'name': 'xiaobai', 'age': '20'} # ... 高级查找 查找年龄大于14的学生 x = mytable.find( {&quot;age&quot;: {&quot;$gt&quot;: &quot;14&quot;}}, {&quot;_id&quot;: 0, &quot;name&quot;: 1} ) # {'name': 'xiaohong'} # {'name': 'xiaobai'} # {'name': 'xiaohei'} # {'name': 'xiaozi'} 使用.limit()来显示返回的答案的数量 x = mytable.find( {&quot;age&quot;: {&quot;$gt&quot;: &quot;14&quot;}}, {&quot;_id&quot;: 0, &quot;name&quot;: 1} ).limit(2) # {'name': 'xiaohong'} # {'name': 'xiaobai'} 以下是一些常用的修饰符条件： $gt（大于）：用于匹配字段值大于指定值的文档。 collection.find({&quot;field_name&quot;: {&quot;$gt&quot;: value}}) $lt（小于）：用于匹配字段值小于指定值的文档。 collection.find({&quot;field_name&quot;: {&quot;$lt&quot;: value}}) $gte（大于等于）：用于匹配字段值大于等于指定值的文档。 collection.find({&quot;field_name&quot;: {&quot;$gte&quot;: value}}) $lte（小于等于）：用于匹配字段值小于等于指定值的文档。 collection.find({&quot;field_name&quot;: {&quot;$lte&quot;: value}}) $ne（不等于）：用于匹配字段值不等于指定值的文档。 collection.find({&quot;field_name&quot;: {&quot;$ne&quot;: value}}) $in（包含于）：用于匹配字段值在指定列表中的文档。 collection.find({&quot;field_name&quot;: {&quot;$in&quot;: [value1, value2, value3]}}) $nin（不包含于）：用于匹配字段值不在指定列表中的文档。 collection.find({&quot;field_name&quot;: {&quot;$nin&quot;: [value1, value2, value3]}}) $exists（存在）：用于匹配具有指定字段的文档。 collection.find({&quot;field_name&quot;: {&quot;$exists&quot;: True}}) $type（类型）：用于匹配字段的数据类型。 collection.find({&quot;field_name&quot;: {&quot;$type&quot;: data_type}}) $regex（正则表达式）：用于执行正则表达式匹配。 collection.find({&quot;field_name&quot;: {&quot;$regex&quot;: &quot;pattern&quot;}}) 这些修饰符条件可用于创建各种查询，以满足你的数据筛选需求。你可以根据文档字段的值和数据类型来选择适当的修饰符条件。 ","link":"https://blog.xn--fiqz59cpva341l.top/post/mongodb-1st/"},{"title":"MapReduce 编程环境配置","content":"准备 hadoop 的包 https://dlcdn.apache.org/hadoop/common/hadoop-3.2.4/hadoop-3.2.4.tar.gz 解压并存放 现代IDE : IntelliJ IDEA 2023.2.3 创建项目 新建项目 在新建项目中选择新建项目（不要选择生成器中的Maven）语言为Java，构建系统为Maven 添加依赖 右上角齿轮图标中找到项目结构，在项目设置-模块中找到依赖，添加以下文件或目录 hadoop-3.2.4\\share\\hadoop\\common hadoop-3.2.4\\share\\hadoop\\common\\lib hadoop-3.2.4\\share\\hadoop\\mapreduce hadoop-3.2.4\\share\\hadoop\\mapreduce\\lib 测试代码 在 IDE 中测试运行 在 \\src\\main\\java 下新建 Java类 WordCount,填入 import java.io.IOException; import java.util.Iterator; import java.util.StringTokenizer; import org.apache.hadoop.conf.Configuration; import org.apache.hadoop.fs.Path; import org.apache.hadoop.io.IntWritable; import org.apache.hadoop.io.Text; import org.apache.hadoop.mapreduce.Job; import org.apache.hadoop.mapreduce.Mapper; import org.apache.hadoop.mapreduce.Reducer; import org.apache.hadoop.mapreduce.lib.input.FileInputFormat; import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat; import org.apache.hadoop.util.GenericOptionsParser; public class WordCount { public WordCount() { } public static void main(String[] args) throws Exception { Configuration conf = new Configuration(); String[] otherArgs = (new GenericOptionsParser(conf, args)).getRemainingArgs(); if (otherArgs.length &lt; 2) { System.err.println(&quot;Usage: wordcount &lt;in&gt; [&lt;in&gt;...] &lt;out&gt;&quot;); System.exit(2); } Job job = Job.getInstance(conf, &quot;word count&quot;); job.setJarByClass(WordCount.class); job.setMapperClass(WordCount.TokenizerMapper.class); job.setCombinerClass(WordCount.IntSumReducer.class); job.setReducerClass(WordCount.IntSumReducer.class); job.setOutputKeyClass(Text.class); job.setOutputValueClass(IntWritable.class); for (int i = 0; i &lt; otherArgs.length - 1; ++i) { FileInputFormat.addInputPath(job, new Path(otherArgs[i])); } FileOutputFormat.setOutputPath(job, new Path(otherArgs[otherArgs.length - 1])); System.exit(job.waitForCompletion(true) ? 0 : 1); } public static class TokenizerMapper extends Mapper&lt;Object, Text, Text, IntWritable&gt; { private static final IntWritable one = new IntWritable(1); private Text word = new Text(); public TokenizerMapper() { } public void map(Object key, Text value, Mapper&lt;Object, Text, Text, IntWritable&gt;.Context context) throws IOException, InterruptedException { StringTokenizer itr = new StringTokenizer(value.toString()); while (itr.hasMoreTokens()) { this.word.set(itr.nextToken()); context.write(this.word, one); } } } public static class IntSumReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt; { private IntWritable result = new IntWritable(); public IntSumReducer() { } public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Reducer&lt;Text, IntWritable, Text, IntWritable&gt;.Context context) throws IOException, InterruptedException { int sum = 0; IntWritable val; for (Iterator i$ = values.iterator(); i$.hasNext(); sum += val.get()) { val = (IntWritable) i$.next(); } this.result.set(sum); context.write(key, this.result); } } } 运行项目，会得到结果 Usage: wordcount &lt;in&gt; [&lt;in&gt;...] &lt;out&gt; 出现报错 HADOOP_HOME and hadoop.home.dir are unset 无伤大雅 打包JAR 右上角齿轮图标中找到项目结构，在项目设置-工件中点击加号，选择JAR - 来自具有依赖项的模块，在主类中选择刚刚编写的WordCount，点击确认，返回 在 菜单 - 构建 中 选择 构建工件... 选择构建 不出意外即可在输出目录找到生成的文件 服务端测试 把文件上传到服务器 启动集群 start-all.sh 创建1.txt 里面编写若干英语单词，并上传到hdfs hdfs dfs -put /home/1.txt /input 运行测试 hadoop jar /home/word.jar /input /output 如果能在output中看到结果就是好的 ","link":"https://blog.xn--fiqz59cpva341l.top/post/mapreduce-bian-cheng-huan-jing-pei-zhi/"},{"title":"Docker 基础入门","content":"1.Docker 安装 卸载原docker(不自带不用作) sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 安装依赖和设置仓库地址 # 安装依赖 yum install -y yum-utils # 添加仓库 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo # 觉得慢，可以设置国内镜像仓库 yum-config-manager --add-repo http://mirrors.aliyun.com/repo/Centos-7.repo yum clean all &amp; yum makecache rm -f /var/run/yum.pid 安装 yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 启动与测试 # 启动 systemctl start docker # 查看版本 docker version # 测试运行 docker run hello-world # 开机自启 systemctl enable docker 卸载docker # 删包 yum remove docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extras # 删文件 rm -rf /var/lib/docker rm -rf /var/lib/containerd 2. Docker 常用命令 2.1 帮助命令 # 帮助命令 docker 命令 --help # 查看版本 docker version # docker的系统信息 docker info 在线帮助文档：https://docs.docker.com/reference/ 2.2 镜像命令 # 查看镜像列表 docker images REPOSITORY TAG IMAGE ID CREATED SIZE hello-world latest 9c7a54a9a43c 5 months ago 13.3kB -a, --all # 显示所有（包括隐藏） -q, --quiet # 只显示ID # 在 dockerhub 搜索镜像 docker search 关键词 -f, --filter filter 过滤例如--filter=START=3000 星标大于3000 # 下载镜像（不写版本默认lastest最新） docker pull 关键词:版本 # 指定版本下载 docker pull mysql:5.7 # 删除镜像 docker rmi 镜像ID 镜像ID... # 删除全部镜像 docker rmi $(docker images -aq) 2.3 容器命令 docker pull centos # 运行命令 docker run 镜像 --name 容器名字 -d 后台运行 -it 交互方式运行 -P 指定端口 -p 主机端口:容器端口 -p ip:主机端口:容器端口 -p 容器端口 -p 随机端口 # 启动、测试 [root@node1 ~]# docker run -it centos bash [root@544d6c37f4af /]# # 退出容器 [root@544d6c37f4af /]# exit exit [root@node1 ~]# # 查看正在运行的容器 docker ps -a 全部容器（包括已经退出的） -n=数字 最近运行的几个容器 -q 只显示ID # 容器停止并退出 exit # 退出容器不停止 Ctrl + P +Q # 删除容器,不能删除正在运行的容器 docker rm 容器ID # 删除全部（强制） docker rm -f $(docker ps -aq) # 启动、重启、停止、强制停止容器 docker start 容器ID docker restart 容器ID docker stop 容器ID docker kill 容器ID # 显示log docker log -tf --tail 数字 -f 循环输出 -t 显示时间 --tail + 数字 显示的条数 # 查看容器中的进程信息 docker top 容器ID # 查看容器的元数据 docker inspect 容器ID # 进入当前正在运行的容器 # 开启一个新的终端 docker exec -it 容器ID bash # 进入容器 docker attach 容器ID # docker 容器和主机复制文件 docker cp 容器ID # 打包镜像 docker commit -a 作者 -m 描述 容器ID 镜像名称 参数 介绍 -a : 提交的镜像作者 -c : 使用Dockerfile指令来创建镜像 **-m ** 提交时的说明文字 **-p ** 在commit时，将容器暂停。 3. WebUI 可视化 # 拉取 docker pull portainer/portainer # 运行 docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer 打开 http://localhost:9000/，完成账户创建， 选择Get Started - Proceed using the local environment which Portainer is running in即可完成配置 都可视化了，内容也没什么好讲解了 4. Docker 镜像 4.1 容器数据卷 运行时创建挂载 docker run -it -v 主机目录:容器目录 # 把主机目录挂载到容器中 mkdir ceshi docker run -it -v $PWD/ceshi:/home centos 容器即使重启依旧会保留挂载 测试安装运行Mysql docker run -d -p 3310:3306 -v $PWD/mysql/conf:/etc/mysql/conf.d -v $PWD/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root mysql:5.7 使用方法: docker volume 命令 create 创建一个volume inspect 展示volume的详细信息 ls 列出所有的volume docker volume ls # DRIVER VOLUME NAME # local 07ecb5d394551af2c70149026ef07b7da4b05de9fedc64cc1e8c0ae4f1f8699d # local e86b118a8373a31957c9cd0ba8a40fca980a4e813e223f82f8036a7e3afb9819 # local portainer_data prune 移除未使用的volume rm 移出一个或多个volume 具名挂载、匿名挂载和指定路径挂载 没有指定目录的情况下默认目录是/var/lib/docker/volumes 匿名挂载： docker run -v 容器内路径 镜像名称 具名挂载： docker run -v 卷名(volume name):容器内路径 镜像名称 指定路径挂载 docker run -v /宿主机路径:容器内路径 镜像名称 4.2 Dockerfile 通过编写Dockerfile文件，可以轻松地构建出自己所需的Docker镜像。 Dockerfile是一种文本文件，用于定义Docker镜像的构建过程。它包含了一系列的指令和参数，用于指导Docker引擎在构建镜像时执行一系列的操作，例如安装软件包、设置环境变量、拷贝文件等。 Dockerfile通常包含以下几个部分： 基础镜像：指定要使用的基础镜像，例如Ubuntu、CentOS等。 维护者信息：指定Docker镜像的维护者信息。 环境变量：设置Docker容器的环境变量。 安装软件包：使用apt-get、yum等包管理器安装需要的软件包。 拷贝文件：将本地文件或目录拷贝到Docker镜像中。 运行命令：在Docker镜像中运行命令，例如启动服务等。 暴露端口：指定Docker容器需要暴露的端口号。 4.2.1 Dockerfile 构建过程 基础知识: 每个保留关键字(指令)都是必须是大写字母 执行从上到下顺序执行 #表示注释 每一个指令都会创建提交一个新的镜像层，并提交! 指令 作用 FROM 这个镜像的妈妈是谁? (指定基础镜像) MAINTAINER 告诉别人，谁负责养它? (指定维护者信息) RUN 你想让它干啥 (在命令前面加上RUN即可) ADD 给它点创业资金 (COPY文件，会自动解压) WORKDIR 我是cd,今天刚化了妆 (设置当前工作目录) VOLUME 给它一个存放行李的地方 (设置卷，挂载主机目录) EXPOSE 它要打开的门是啥 (指定对外的端口) CMD 启动时要运行的命令,只有最后一个生效 ENTERPOINT 启动时要运行的命令,可以追加 OUYTBUILD 当构建一个被继承 DockerFile 这个时候就会运行 ONBUILD 的指令。触发指令 COPY 类似ADD , 把文件拷贝到镜像 ENV 构建时的环境变量 构建一个centos7 FROM centos:7 MAINTAINER 123&lt;123@qq.com&gt; ENV MYPATH /usr/local WORKDIR $MYPATH RUN yum -y install vim RUN yum -y install net-tools EXPOSE 80 CMD echo $MYPATH CMD echo &quot;---END---&quot; CMD bash 构建文件 docker build -f 文件 -t 镜像名称:TAG版本 . # 最后有一个点！ # 如果已经有Dockerfile，就不需要-f指定文件了 4.3 Docker 网络 ","link":"https://blog.xn--fiqz59cpva341l.top/post/docker-ji-chu-ru-men/"},{"title":"Flink 环境配置","content":"1. 下载安装 官网下载：https://flink.apache.org/zh/downloads/ wget https://dlcdn.apache.org/flink/flink-1.16.2/flink-1.16.2-bin-scala_2.12.tgz --no-check-certificate tar -zxvf flink-1.16.2-bin-scala_2.12.tgz 2. 配置 添加子节点 vim conf/workers node2 node3 启动 bin/start-cluster.sh bin/stop-cluster.sh 分发 cd ../ scp -r flink-1.16.2/ node2:$PWD 运行示例 bin/flink run examples/streaming/WordCount.jar ","link":"https://blog.xn--fiqz59cpva341l.top/post/flink-huan-jing-pei-zhi/"},{"title":"Hive 环境配置","content":"1. 安装 Mysql 官网链接：https://dev.mysql.com/downloads/mysql/ 找到合适自己系统的版本 TIPS: centos 属于 Red Hat 选择 yum 下载 Red Hat Enterprise Linux 7 / Oracle Linux 7 (Architecture Independent), RPM Package # 安装 yum -y install https://dev.mysql.com/get/mysql80-community-release-el7-10.noarch.rpm yum -y install mysql-community-server # 启动服务 systemctl start mysqld # 开机自启 systemctl enable mysqld 获取密码 grep 'temporary password' /var/log/mysqld.log 密码在最后 2023-10-07T12:26:49.768296Z 6 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: 6eXFr#e;=slo 登录 mysql -u root -p 修改密码策略 set global validate_password.policy=0; set global validate_password.length=0; set global validate_password.check_user_name=off; 修改密码为 root alter user 'root'@'localhost' identified by 'root'; 授权访问 use mysql; create user root@'%' identified by 'root'; grant all privileges on *.* to root@'%' with grant option; flush privileges; 2. 安装 Hive 官网：https://dlcdn.apache.org/hive/ 找到合适的版本 下载解压进入 cd /user/ wget https://dlcdn.apache.org/hive/hive-3.1.3/apache-hive-3.1.3-bin.tar.gz --no-check-certificate tar -zvxf apache-hive-3.1.3-bin.tar.gz rm -f apache-hive-3.1.3-bin.tar.gz cd apache-hive-3.1.3-bin 解决重复可能冲突的包 rm -f lib/guava-19.0.jar cp $HADOOP_HOME/share/hadoop/common/lib/guava-27.0-jre.jar ./lib/ 修改hive-env.sh cd conf/ mv hive-env.sh.template hive-env.sh vim hive-env.sh HADOOP_HOME=$HADOOP_HOME export HIVE_CONF_DIR=/user/hive/conf/ export HIVE_AUX_JARS_PATH=/user/hive/lib/ 修改hive-site.xml vim hive-site.xml &lt;?xml version=&quot;1.0&quot;?&gt; &lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt; &lt;configuration&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt; &lt;value&gt;jdbc:mysql://node1:3306/hive?createDatabaseIfNotExist=true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt; &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;!-- mysql账号和密码 --&gt; &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt; &lt;value&gt;root&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt; &lt;value&gt;root&lt;/value&gt; &lt;/property&gt; &lt;!-- 关闭元数据存储授权 --&gt; &lt;property&gt; &lt;name&gt;hive.metastore.event.db.notification.api.auth&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt; &lt;!-- 关闭元数据存储版本的验证 --&gt; &lt;property&gt; &lt;name&gt;hive.metastore.schema.verification&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 添加mysql jdbc包 进入网站 https://dev.mysql.com/downloads/connector/j/ 选择 Platform Independent 获取下载链接 cd lib # 下载 wget https://dev.mysql.com/get/Downloads/Connector-J/mysql-connector-j-8.1.0.zip # 解压移动 unzip mysql-connector-j-8.1.0.zip mv mysql-connector-j-8.1.0/mysql-connector-j-8.1.0.jar ./ # 删除 rm -rf mysql-connector-j-8.1.0.zip mysql-connector-j-8.1.0 初始化 # 返回hive cd ../ bin/schematool -initSchema -dbType mysql -verbose 测试启动 bin/hive ","link":"https://blog.xn--fiqz59cpva341l.top/post/hive-huan-jing-pei-zhi/"},{"title":"Scala 环境配置","content":"1. 下载安装 1.1 一键安装 来到官网 https://www.scala-lang.org/download/ 找到你的平台 复制他给你的指令 curl -fL https://github.com/coursier/coursier/releases/latest/download/cs-x86_64-pc-linux.gz | gzip -d &gt; cs &amp;&amp; chmod +x cs &amp;&amp; ./cs setup 有个要你输入Y确认 等一等就好了 它从github下载的，请保持网络良好 刷新一下环境变量 source ~/.profile source ~/.bash_profile 你可能想知道它安装到哪里去了，它在这$PATH:/root/.local/share/coursier/bin，打开~/.profile就能看到了，但这不是scala的目录，是cs的 1.2 手动安装 来到官网 https://github.com/lampepfl/dotty/releases 找到某发行版的Assets的scala3-3.3.1.tar.gz cd /user/ # 下载 wget https://github.com/lampepfl/dotty/releases/download/3.3.1/scala3-3.3.1.tar.gz # 解压 tar -zxvf scala3-3.3.1.tar.gz # 删安装包 rm -f scala3-3.3.1.tar.gz 添加环境变量 vim /etc/profile 末尾添加 #SCALA_HOME export SCALA_HOME=/usr/scala3-3.3.1 export PATH=$PATH:$SCALA_HOME/bin:$SCALA_HOME source /etc/profile 3. 测试 输入 scala -version 有下面这样的输出就好了 Scala code runner version 3.3.1 -- Copyright 2002-2023, LAMP/EPFL ","link":"https://blog.xn--fiqz59cpva341l.top/post/scala-huan-jing-pei-zhi/"},{"title":"Spark 环境配置","content":"1.下载安装 来到下载页面 https://spark.apache.org/downloads.html 找一个合适自己Hadoop版本的版本 spark-3.2.4-bin-hadoop3.2.tgz 也可以选择不带hadoop的版本，但是后期步骤不一样 解压后先完成 2.2 设置配置 spark-env.sh 里面多加一行 ( hadoop需存在于环境变量 ) export SPARK_DIST_CLASSPATH=$(hadoop classpath) 下载一下 cd usr/ wget https://archive.apache.org/dist/spark/spark-3.2.4/spark-3.2.4-bin-hadoop3.2.tgz --no-check-certificate 解压一下 tar -zxvf spark-3.2.4-bin-hadoop3.2.tgz 改个名字 mv spark-3.2.4-bin-hadoop3.2 spark 删掉安装包 rm -f spark-3.2.4-bin-hadoop3.2.tgz 2.配置 2.1 环境变量 vim /etc/profile 末尾添加 #SPARK_HOME export SPARK_HOME=/usr/spark export PATH=$PATH:$SPARK_HOME/bin:$SPARK_HOME source /etc/profile 测试，输入 spark-shell 一番等待如果出现 ____ __ / __/__ ___ _____/ /__ _\\ \\/ _ \\/ _ `/ __/ '_/ /___/ .__/\\_,_/_/ /_/\\_\\ /_/ 就是成功了 2.2 其他配置 这一步，可以跳过！ 里面文件目录根据实际写，但我实测这个文件不创建也能运行web网页 cd spark/conf/ mv spark-env.sh.template spark-env.sh vim spark-env.sh export SCALA_HOME=/usr/scala export JAVA_HOME=/usr/java/jdk1.8.0_202-amd64 export HADOOP_HOME=/usr/hadoop-3.2.4 export SPARK_HOME=/home/hadoop/app/spark-1.4.0 export SPARK_PID_DIR=$SPARK_HOME/tmp SPARK_MASTER_IP=node1 SPARK_LOCAL_DIRS=/usr/spar/ SPARK_DRIVER_MEMORY=1G SPARK_MASTER_PORT=4050 SPARK_WORKER_CORES=30 SPARK_WORKER_MEMORY=60g SPARK_WORKER_INSTANCES=6 SPARK_DRIVER_MEMORY=12g 添加子节点 mv workers.template workers vim workers node2 node3 3.分发 分发到子节点 cd /usr/ scp -r spark/ node2:$PWD scp -r spark/ node3:$PWD 4.检验 开启 $SPARK_HOME/sbin/start-all.sh webUI要能启动 http://node1:8080 关闭 $SPARK_HOME/sbin/stop-all.sh ","link":"https://blog.xn--fiqz59cpva341l.top/post/spark-huan-jing-pei-zhi/"},{"title":"Tomcat 的 安装","content":"今天浅浅配置一个Tomcat环境 下载Tomcat 来到官网，查看左侧边栏，在 Download 里找到中意的版本，比如 Tomcat 10 ，然后在右侧 Binary Distributions - Core 里面，有下载链接 里面提供有两种包 ZIP 和EXE安装包，目前看来 exe 可以直接启动tomcat10w来直接开启服务器 配置 我们选择zip，解压 开始配置环境变量 打开设置，系统，系统信息，高级系统设置，环境变量，系统变量 添加 变量 值（示例） CATALINA_HOME C:\\Users\\AW\\Desktop\\apache-tomcat-10.1.13 JAVA_HOME C:\\Program Files\\Java\\jdk-20 双击 Path 添加 %JAVA_HOME%\\bin 启动！ 打开终端，cd 进入 tomcat\\bin 所在目录 cd C:\\Users\\AW\\Desktop\\apache-tomcat-10.1.13\\bin\\ 运行启动脚本 .\\startup.bat 打开 http://localhost:8080/ ， 如果能成功打开即为安装配置成功 ","link":"https://blog.xn--fiqz59cpva341l.top/post/tomcat-de-an-zhuang/"},{"title":"Xposed——基本Hook","content":"外部框架 class AlwaysShowCleanUp: BaseHook() { override fun init() { // 往下写 } 几种方法定位方法的例子 loadClass loadClass(&quot;类名&quot;).methodFinder() .filterByName(&quot;方法名&quot;) .first().createHook { before { // 操作 // it.result = true } } hookAllMethods hookAllMethods( &quot;类名&quot;, &quot;方法名&quot;, object : MethodHook() { override fun before(param: MethodHookParam) { // 操作 //param.result = true } }) ","link":"https://blog.xn--fiqz59cpva341l.top/post/xposed-hook/"},{"title":"html笔记——23-08-06","content":"媒体查询 @media 常用于响应式布局，规定了在不同的条件下的样式 // 格式 @media ('条件') { '样式' } 常见的格式: orientation: landscape min-width: 768px max-width: 768px 一些单位 (vh dvh svh em rem) vh dvh svh 这个单位是相对于浏览器的可视显示大小 vh 是一般的但是在手机等移动端可能会有一些其他的浏览器控件（地址栏，快捷栏）妨碍显示，为了解决这个问题，一般使用 dvh 或 svh ,前者是动态获取大小（如手机地址栏滑动时会隐藏）和最小显示大小 em rem em和rem都是相对的，em相对于父元素字体大小，rem相对于根元素字体大小 Overflow 这个属性用于决定当元素超出父元素显示范围时候的显示模式 几种常用属性: overflow: visible; 直接超出去！ overflow: hidden; 被挡住看不到了！ overflow: clip; 切掉了不要了！ overflow: scroll; 横竖都能滚！ overflow: auto; 怎么滚？看着办！ getElementByxx 和 querySelector querySelector 相较于前者可以使用css的选择器来选择元素，可能更灵活？ 下面是gpt写的: getElementById：根据元素的 id 属性获取单个元素。返回匹配的第一个元素，因为 id 在&gt;文档中应该是唯一的。 var element = document.getElementById(&quot;myElement&quot;); getElementsByClassName：根据元素的类名获取一组元素。返回一个类数组对象&gt;（HTMLCollection 或者 NodeList），包含所有具有指定类名的元素。 var elements = document.getElementsByClassName(&quot;myClass&quot;); getElementsByTagName：根据元素的标签名获取一组元素。返回一个类数组对象&gt;（HTMLCollection 或者 NodeList），包含所有指定标签名的元素。 var elements = document.getElementsByTagName(&quot;div&quot;); querySelector：根据 CSS 选择器获取单个元素。返回匹配的第一个元素。 var element = document.querySelector(&quot;#myElement&quot;); querySelectorAll：根据 CSS 选择器获取一组元素。返回一个静态的 NodeList，包含所有匹&gt;配选择器的元素。 var elements = document.querySelectorAll(&quot;.myClass&quot;); 需要注意的是，getElementByxx 系列方法返回的是类数组对象，而 querySelector 和 &gt;querySelectorAll 返回的是 NodeList。此外，querySelector 和 querySelectorAll &gt;支持更复杂的 CSS 选择器，而 getElementByxx 系列方法只能使用 id、类名和标签名进行 常见transform 动画 写动画之前要加transition: 0.3s;，不然没动画 平移 translate() ：translateX() translateY() 缩放 scale() ：scaleX() scaleY()(单横竖缩放) 旋转 rotate() ： 倾斜 skew() ：skewX() skewY() 3D转换（3D Transform）： translate3d()、scale3d()、rotate3d() 常见伪类 状态类 :hover 鼠标悬停 :active 鼠标点击 :focus 是焦点 :checked 复选框选上了 逻辑类 :is() 相当于小括号 :not() 猜猜谁没有收到邀请？是- :not() 伪元素来凑个热闹 ::after ::before 在控件前后追加内容，同时分开样式 选择元素的: :first-child：选择父元素中的第一个子元素。 :last-child：选择父元素中的最后一个子元素。 :nth-child(n)：选择父元素中的第n个子元素，其中n是一个数字。 :nth-last-child(n)：选择父元素中的倒数第n个子元素，其中n是一个数字。 css 选择器进阶 属性选择器：基于元素的属性值进行选择。 [attribute]：选择具有指定属性的元素。 [attribute=value]：选择属性值与指定值匹配的元素。 [attribute^=value]：选择属性值以指定值开头的元素。 符号 &gt;: 在 CSS 选择器中，符号 &gt; 表示子元素选择器，用于选择直接位于指定元素内的子元素。它的语法是通过将两个选择器用 &gt; 分隔开来。 ","link":"https://blog.xn--fiqz59cpva341l.top/post/html-bi-ji-23-08-06/"},{"title":"html笔记——23-07-25","content":"入门了三件套很激动，连夜模仿了一个UI出来，下面是一些笔记 模仿的是 ChatGPT-Next-Web 随机数 radomint js 只有 radom 函数生成0到1的随机数，所以 radomint 要自己写 // 前闭后开 function randomint(a, b) { num = Math.floor(Math.random() * (b - a)) + a; return num; } // 前闭后闭（看看就好了） function randomint(a, b) { num = Math.floor(Math.random() * (b - a + 1)) + a; return num; } 移动端适配 必写的好吧 先是显示大小 &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=0.75,user-scalable=no&quot;&gt; 再是布局调整，看看你是不是手机 function isMobileDevice() { return /Android|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent); } 看完了，是手机，那就开刀，该显示显示，该隐藏隐藏 window.onload = function () { if (isMobileDevice()) { // 当前浏览器是手机浏览器 } else { // 当前浏览器不是手机浏览器 } } 垂直布局和水平布局 外层写 display: flex; flex-direction: column; // 垂直布局 flex-direction: row; // 水平布局 // 扩展内容 flex-wrap: nowrap; // （默认）：不换行 flex-wrap: wrap; // 换行 justify-content: center; // 对齐方式 align-items: center; // 也是，但不一样，具体看文档 内层写 flex: 1; flex: 0; flex 属性是 flex-grow , flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 （写第一个就行了,因为 flex 比 flex-grow 短） body 的默认 margin body默认居然是有margin` 的，看他不爽一定要删掉 body { margin: 0px; } 全局样式 * 是可以匹配所有元素的，可以一键设置初始字体样式或者是其他样式 * { text-align: center; } 颜色的表示 // 第一种 写英文 white // 第二种 #开头的16进制表示 #ooff66 // 第三种 rgb颜色表示 rgb(246, 246, 246) // 第四种 在上面的基础上加上 a rgba(0, 0, 0, 0.1) box-shadow 阴影 box-shadow 属性用于在元素的框架上添加阴影效果。你可以在同一个元素上设置多个阴影效果，并用逗号将他们分隔开。该属性可设置的值包括阴影的 X 轴偏移量、Y 轴偏移量、模糊半径、扩散半径和颜色。 如果元素同时设置了 border-radius 属性，那么阴影也会有圆角效果 在线阴影生成器，太好用啦 看看 几个参数看看 inset 阴影在里面还是外面 position x position y 这是相对主元素的位置 blur 模糊程度 spread 扩散度（大小） 例子 box-shadow: 10px 10px 30px rgba(0, 0, 0, 0.1); 这个属性文字也有，是专门的 text-transform 单位的意思和使用 在CSS的计量单位体系中，可以分为相对长度单位和绝对长度单位： 相对长度单位包括：em、ex、ch、rem、vw、vh、vmin、vmax、% 绝对长度单位包括：cm、mm、in、px、pt、pt、pc px：就是像素 vh、vw 在移动端体验极差啊哈，不要使用啊哈 view height 窗口高度 这里的窗口分成几种情况： 在桌面端指的是浏览器的可视区域 在移动端指的就是布局视口 百分比 相对于父元素的百分比 不同单位的计算 介绍 calc() 此 CSS 函数允许在声明 CSS 属性值时执行一些计算。它可以用在如下场合：&lt;length&gt;、&lt;frequency&gt;, &lt;angle&gt;、&lt;time&gt;、&lt;percentage&gt;、&lt;number&gt;、或 &lt;integer&gt;。 例子： width: calc(100% - 80px); 动画效果 transition: 样式名称 持续时间 曲率; 写到这差不多了 ","link":"https://blog.xn--fiqz59cpva341l.top/post/html-bi-ji-23-07-25/"},{"title":"Javascript 概述","content":"很简陋 1. 什么是Javascript, 和Java有什么关系 Javascript 是一个脚本语言 蹭热度的，没关系 2. JS 是干啥的 HTML是主体 CSS是修饰 JS是操作HTML和CSS达到网页动态效果 3. JS 嵌入 HTML 的方式 Javascript是一个事件驱动型的编程语言，一般靠事件触发 3.1 在事件句柄中提供JS代码 事件句柄都是以标签形式存在 事件不发生，代码不执行 &lt;input type=&quot;reset&quot; onclick=&quot;window.alert('重置成功！')&quot;&gt; window.可以省略，; 不一定要写 3.2 使用脚本块 JS的注释和Java相同 会在网页打开时自上而下运行 脚本块可以多个，没有位置限制 &lt;script&gt; // 这是注释 alert('广告:XXXXX') &lt;/script&gt; 3.3 加载来自外部的js文件 &lt;script src=&quot;js/s1.js&quot;&gt; 4. JS 的变量 省流，Java杂合Python 变量是 var 常量是 const js是一种弱类型语言 和python一样变量类型不用定义 可以随时更改数据类型 var age = 20 age = &quot;变量变成string了&quot; // 变量没有赋值时默认为undefined ``` 56789 ```js // 类似println，输出到控制台 console.log(age) 5. JS 的函数 省流，和Python一样 定义： function myadd (a, b) { alert(a + b) } 调用： add(1, 2) 6. JS 的事件 6.1 常用事件 点击事件： onclick 单击事件 ondblclick 双击事件 焦点事件 onblur 失去焦点 onfocus 元素获得焦点 加载事件： onload 一张页面或一幅图像完成加载 鼠标事件： onmousedown 鼠标按钮被按下 onmouseup 鼠标按键被松开 onmousemove 鼠标被移动 onmouseover 鼠标移到某元素之上 onmouseout 鼠标从某元素移开 键盘事件： onkeydown 某个键盘按键被按下 onkeyup 某个键盘按键被松开 onkeypress 某个键盘按键被按下并松开 选择和改变 onchange 域的内容被改变 onselect 文本被选中 表单事件： onsubmit 确认按钮被点击 onreset 重置按钮被点击 7. 获取页面中的节点 document.getElementsByClassName() 返回文档中所有指定类名的元素集合，作为 NodeList 对象 document.getElementById() 返回对拥有指定 id 的第一个对象的引用 document.getElementsByName() 返回带有指定名称的对象集合 document.getElementsByTagName() 返回带有指定标签名的对象集合。 除了ID其他结果都是集合！ 可以在控制台输入指令直观展示结果 8. 节点内容获取与修改 使用 innerHTML 属性 设置或返回表格行的开始和结束标签之间的东西 function myadd() { a = document.getElementById('logo') a.innerHTML = 1111 b = a.innerHTML alert(b) } innerText 与 innerHTML innerText 是内容 innerHTML 是纯文本 使用 value 属性 设置或返回表格行的开始和结束标签之间的东西 标签有什么属性，就能 对象.属性，可以获取也可以赋值 9. 复选框的全选和取消 懒，不写了 思路：利用checked获取checkbox选中状态并设置状态 知识点：判断和循环遍历 if(){ // 和Java一样 } for(var i = 0; i &lt; a.length; i++){ // 和Java一样 } 10. 表单验证 trim()去除前后空白 判断空值 判断长度 正则判断 var regExp = /^[0-9a-z]$/ regExp.test(text) ","link":"https://blog.xn--fiqz59cpva341l.top/post/javascript/"},{"title":"CSS 概述","content":"等于没讲 1.什么是CSS？ CSS（层叠样式表）是一种样式表语言，专门用来修饰HTML的 2. HTML 中嵌入 CSS 的方式 2.1 内联定义 格式: &lt;标签 style=&quot;样式名: 样式; 样式名: 样式;&quot;&gt;hello&lt;/标签&gt; &lt;div style=&quot;color: blueviolet;&quot;&gt;hello&lt;/div&gt; 2.2 样式块定义 常见的选择元素的方式: ID选择器 #mydiv{ width: 100px; height: 100px; } 标签选择器 input { /* 作用域当前页面中所有的XXX元素 */ width: 100px; height: 100px; } 类选择器 &lt;style&gt; .student { width: 100px; height: 100px; } &lt;/style&gt; &lt;div class=&quot;student&quot;&gt;hello&lt;/div&gt; 优先级 ID选择器 &gt; 类选择器 &gt; 标签选择器 2.3 外联定义 &lt;link rel=&quot;stylesheet&quot; href=&quot;css/my.css&quot;&gt; 3. 常见的CSS样式 以下内容不如看书 这是书📖 3.1 display 元素显示方式 inline-block 元素之后不添加换行符 block 元素之后添加换行符 none 隐藏 3.2 text-decoration 文本修饰 underline 下划线 none 无 3.3 list-style-type 列表前缀风格 none 无 square disc circle 3.4 :hover 鼠标悬停 a:hover{ color: burlywood; } 3.5 内补丁、外补丁 外补丁 margin 元素外部边距 margin-top margin-bottom margin-left margin-right 内补丁 padding 元素内部边距 padding-top padding-bottom padding-right padding-left 3.6 定位 float 当前元素在父元素中的浮动效果 position static relative absolute fixed sticky ","link":"https://blog.xn--fiqz59cpva341l.top/post/css-gai-shu/"},{"title":"HTML 笔记 —— 其二","content":"接上一篇 8. 表单 8.4 下拉框显示多个条目，多选 size=&quot;&quot;显示条目数量 multiple多选 &lt;select name=&quot;pro&quot; multiple size=&quot;7&quot;&gt; &lt;option value=&quot;1&quot;&gt;11111&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;22222&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;33333&lt;/option&gt; &lt;/select&gt; 8.5 file 标签 用于上传文件 &lt;input type=&quot;file&quot; name=&quot;&quot;&gt; 8.6 hidden 控件 网页不会显示，但是提交时会附加 &lt;input type=&quot;hidden&quot; name=&quot;&quot; value=&quot;&quot;&gt; 8.7 其他属性 readonly 可见不可改 可 提交 disabled 可见不可改 不可 提交 maxlength=&quot;&quot; 输入内容 的最大长度 9. ID 属性 每一个节点都有id属性 id是这个节点对象的唯一标识，或者说id是这个节点的身份证编号。 在同一个HTML文档当中id具有唯一性，不可重复 10. div 和 span 控件 10.1什么div 图层、盒子 专门用来做网页布局，比table布局更方便、灵活 10.2 div 和 span 的区别 div 会占用一行，span 不会 ","link":"https://blog.xn--fiqz59cpva341l.top/post/html-bi-ji-qi-er/"},{"title":"微信历史版本官方直链合集","content":"可能是目前最全的官方老版本直链合集 所有链接都是官方链接，从官网提取 包含了微信7到8所有正式版的最后一次小更新 2023/7/7 文章首发 2023/7/15 增加了更新日志,优化了排版 版本:8.0.38 发布时间:2023-06-21 更新日志: 修复了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin8038android2400_1.apk 64位: https://dldir1.qq.com/weixin/android/weixin8038android2400_arm64_1.apk 版本:8.0.37 发布时间:2023-05-25 更新日志: 修复了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin8037android2380_1.apk 64位: https://dldir1.qq.com/weixin/android/weixin8037android2380_arm64_1.apk 版本:8.0.35 发布时间:2023-04-20 更新日志: 修复了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin8035android2360_3.apk 64位: https://dldir1.qq.com/weixin/android/weixin8035android2360_arm64_3.apk 版本:8.0.34 发布时间:2023-03-23 更新日志: 修复了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin8034android2340_1.apk 64位: https://dldir1.qq.com/weixin/android/weixin8034android2340_arm64_1.apk 版本:8.0.33 发布时间:2023-02-23 更新日志: 修复了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin8033android2320_1.apk 64位: https://dldir1.qq.com/weixin/android/weixin8033android2320_arm64_1.apk 版本:8.0.32 发布时间:2023-01-06 更新日志: 修复了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin8032android2300_3.apk 64位: https://dldir1.qq.com/weixin/android/weixin8032android2300_arm64_3.apk 版本:8.0.31 发布时间:2022-12-08 更新日志: 修复了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin8031android2281.apk 64位: https://dldir1.qq.com/weixin/android/weixin8031android2281_arm64.apk 版本:8.0.30 发布时间:2022-11-10 更新日志: 修复了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin8030android2260_1.apk 64位: https://dldir1.qq.com/weixin/android/weixin8030android2260_arm64_1.apk 版本:8.0.28 发布时间:2022-09-16 更新日志: 修复了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin8028android2240.apk 64位: https://dldir1.qq.com/weixin/android/weixin8028android2240_arm64.apk 版本:8.0.27 发布时间:2022-08-18 更新日志: 修复了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin8027android2220_1.apk 64位: https://dldir1.qq.com/weixin/android/weixin8027android2220_arm64_1.apk 版本:8.0.25 发布时间:2022-07-21 更新日志: 修复了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin8025android2200_1.apk 64位: https://dldir1.qq.com/weixin/android/weixin8025android2200_arm64_1.apk 版本:8.0.24 发布时间:2022-06-27 更新日志: 修复了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin8024android2180.apk 64位: https://dldir1.qq.com/weixin/android/weixin8024android2180_arm64.apk 版本:8.0.23 发布时间:2022-05-26 更新日志: 修复了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin8023android2160_1.apk 64位: https://dldir1.qq.com/weixin/android/weixin8023android2160_arm64_1.apk 版本:8.0.22 发布时间:2022-04-29 更新日志: 修复了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin8022android2140_1.apk 64位: https://dldir1.qq.com/weixin/android/weixin8022android2140_arm64_1.apk 版本:8.0.21 发布时间:2022-04-01 更新日志: 修复了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin8021android2120_1.apk 64位: https://dldir1.qq.com/weixin/android/weixin8021android2120_arm64_1.apk 版本:8.0.20 发布时间:2022-03-03 更新日志: 修复了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin8020android2100.apk 64位: https://dldir1.qq.com/weixin/android/weixin8020android2100_arm64.apk 版本:8.0.19 发布时间:2022-01-25 更新日志: 修复了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin8019android2080_4.apk 64位: https://dldir1.qq.com/weixin/android/weixin8019android2080_arm64_4.apk 版本:8.0.18 发布时间:2022-01-13 更新日志: 修复了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin8018android2060_1.apk 64位: https://dldir1.qq.com/weixin/android/weixin8018android2060_arm64_1.apk 版本:8.0.16 发布时间:2021-10-29 更新日志: 修复了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin8016android2040_1.apk 64位: https://dldir1.qq.com/weixin/android/weixin8016android2040_arm64_1.apk 版本:8.0.15 发布时间:2021-09-29 更新日志: 修复了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin8015android2020_1.apk 64位: https://dldir1.qq.com/weixin/android/weixin8015android2020_arm64_1.apk 版本:8.0.14 发布时间:2021-09-24 更新日志: 可开启「关怀模式」，文字与按钮更大更清晰。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin8014android2000_2.apk 64位: https://dldir1.qq.com/weixin/android/weixin8014android2000_arm64_2.apk 版本:8.0.11 发布时间:2021-08-26 更新日志: 修复了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin8011android1980_1.apk 64位: https://dldir1.qq.com/weixin/android/weixin8011android1980_arm64_1.apk 版本:8.0.10 发布时间:2021-08-16 更新日志: 修复了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin8010android1961_3.apk 64位: https://dldir1.qq.com/weixin/android/weixin8010android1961_arm64_3.apk 版本:8.0.9 发布时间:2021-07-29 更新日志: 可以设置个性来电铃声和消息提示音。 可以在消息免打扰的群里，关注特定群成员。 可以在电脑、平板等设备同时登录同一个微信号。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin809android1940.apk 64位: https://dldir1.qq.com/weixin/android/weixin809android1940_arm64.apk 版本:8.0.7 发布时间:2021-07-02 更新日志: 修复了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin807android1920.apk 64位: https://dldir1.qq.com/weixin/android/weixin807android1920_arm64.apk 版本:8.0.6 发布时间:2021-05-27 更新日志: 修复了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin806android1900.apk 64位: https://dldir1.qq.com/weixin/android/weixin806android1900_arm64.apk 版本:8.0.3 发布时间:2021-04-22 更新日志: 修复了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin803android1880.apk 64位: https://dldir1.qq.com/weixin/android/weixin803android1880_arm64.apk 版本:8.0.2 发布时间:2021-03-25 更新日志: 修复了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin802android1860_1.apk 64位: https://dldir1.qq.com/weixin/android/weixin802android1860_arm64_1.apk 版本:8.0.1 发布时间:2021-02-05 更新日志: 修复了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin801android1840_1.apk 64位: https://dldir1.qq.com/weixin/android/weixin801android1840_arm64_1.apk 版本:8.0.0 发布时间:2021-01-25 更新日志: 更新了若干功能。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin800android1840_1.apk 64位: https://dldir1.qq.com/weixin/android/weixin800android1840_arm64_1.apk 版本:7.0.22 发布时间:2020-12-25 更新日志: 修复了一些已知的问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin7022android1820_1.apk 64位: https://dldir1.qq.com/weixin/android/weixin7022android1820_arm64_1.apk 版本:7.0.21 发布时间:2020-11-26 更新日志: 修复了一些已知的问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin7021android1800.apk 64位: https://dldir1.qq.com/weixin/android/weixin7021android1800_arm64.apk 版本:7.0.20 发布时间:2020-10-29 更新日志: 可以在设置中开启青少年模式。 可以在会话的表情面板中搜索表情。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin7020android1780.apk 64位: https://dldir1.qq.com/weixin/android/weixin7020android1780_arm64.apk 版本:7.0.19 发布时间:2020-09-17 更新日志: 修复了一些已知的问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin7019android1760.apk 64位: https://dldir1.qq.com/weixin/android/weixin7019android1760_arm64.apk 版本:7.0.18 发布时间:2020-08-20 更新日志: 修复了一些已知的问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin7018android1740.apk 64位: https://dldir1.qq.com/weixin/android/weixin7018android1740_arm64.apk 版本:7.0.17 发布时间:2020-07-23 更新日志: 视频号新增“浮评”功能，你可以在观看视频的同时看评论了。 在聊天中，长按消息的菜单有了新样式。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin7017android1720.apk 64位: https://dldir1.qq.com/weixin/android/weixin7017android1720_arm64.apk 版本:7.0.16 发布时间:2020-06-28 更新日志: 修复了一些已知的问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin7016android1700.apk 64位: https://dldir1.qq.com/weixin/android/weixin7016android1700_arm64.apk 版本:7.0.15 发布时间:2020-05-28 更新日志: 深色模式可以不跟随系统，单独设置（深色模式需手机系统支持）。 可在群聊附件栏中直接发起“接龙”。 在微信内点击新消息通知，当前浏览的网页、小程序等将自动收为浮窗。 可以收藏小程序指定页面。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin7015android1680.apk 64位: https://dldir1.qq.com/weixin/android/weixin7015android1680_arm64.apk 版本:7.0.14 发布时间:2020-04-30 更新日志: 可以给群聊设置备注，该备注仅自己可见。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin7014android1660.apk 64位: https://dldir1.qq.com/weixin/android/weixin7014android1660_arm64.apk 版本:7.0.13 发布时间:2020-04-02 更新日志: 可跟随系统的设置，切换为深色模式。 优化了语音消息的发送体验，上滑转文字更方便了。 为方便你更好地了解微信如何使用你的个人信息，便于你对其加以管理，我们更新了 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin7013android1640.apk 64位: https://dldir1.qq.com/weixin/android/weixin7013android1640_arm64.apk 版本:7.0.12 发布时间:2020-03-05 更新日志: 解决了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin7012android1620.apk 64位: https://dldir1.qq.com/weixin/android/weixin7012android1620_arm64.apk 版本:7.0.11 发布时间:2020-02-23 更新日志: 解决了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin7011android1600.apk 64位: https://dldir1.qq.com/weixin/android/weixin7011android1600_arm64.apk 版本:7.0.10 发布时间:2019-12-26 更新日志: 发消息时，可以引用之前的内容。 为方便你更好地了解微信新功能如何使用你的个人信息，我们于2020年1月21日更新了 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin7010android1580.apk 64位: https://dldir1.qq.com/weixin/android/weixin7010android1580_arm64.apk 版本:7.0.9 发布时间:2019-11-28 更新日志: 解决了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin709android1560.apk 64位: https://dldir1.qq.com/weixin/android/weixin709android1560_arm64.apk 版本:7.0.8 发布时间:2019-10-31 更新日志: 解决了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin708android1540.apk 版本:7.0.7 发布时间:2019-09-25 更新日志: 解决了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin707android1520.apk 版本:7.0.6 发布时间:2019-07-26 更新日志: 可以将收藏的笔记、文件预览等页面设为浮窗。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin706android1480.apk 版本:7.0.5 发布时间:2019-07-04 更新日志: 解决了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin705android1440.apk 版本:7.0.4 发布时间:2019-04-16 更新日志: 发「视频动态」时，可以搜一首歌设为背景音乐。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin704android1420.apk 版本:7.0.3 发布时间:2019-01-30 更新日志: 解决了一些已知问题。 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin703android1400.apk 版本:7.0.0 发布时间:2018-12-30 更新日志: 可以拍一个「视频动态」，记录眼前的世界。也可以给朋友的视频冒个泡，告诉他你来过。 界面全新改版，更清晰直观的视觉与操作体验。 可以在看一看里浏览朋友认为好看的文章。 在聊天详情页中，可以给单聊设置强提醒。 为方便你更好地了解微信如何使用你的个人信息，便于你对其加以管理，我们更新了 下载地址: 32位: https://dldir1.qq.com/weixin/android/weixin700android1380.apk 本文使用自制python脚本生产制作，脚本开源地址 https://github.com/lswlc33/wechat_desc_and_download ","link":"https://blog.xn--fiqz59cpva341l.top/post/wei-xin-li-shi-ban-ben-guan-fang-zhi-lian-he-ji/"},{"title":"HTML 笔记 —— 其一","content":"1.1 基本结构 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;title&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;/html&gt; 1.2 基本标签 &lt;p&gt;hello&lt;/p&gt; # 段落标记 &lt;h1&gt;hello&lt;h1/&gt; # 标题字 &lt;br&gt; # 换行 &lt;hr color=&quot;red&quot;&gt; # 水平线 &lt;pre&gt; for i in range(10): print(i) &lt;/pre&gt; # 预留格式 &lt;b&gt;hello&lt;/b&gt; # 粗体字 &lt;i&gt;hello&lt;/i&gt; # 斜体字 &lt;ins&gt;hello&lt;/ins&gt; # 插入字（下划线） &lt;del&gt;hello&lt;/del&gt; # 删除字（删除线） &lt;sup&gt;hello&lt;/sup&gt; # 右上角加字（上标） &lt;sub&gt;hello&lt;/sub&gt; # 右下角加字（下标） &lt;font size=&quot;10&quot; color=&quot;blue&quot;&gt;hello&lt;/font&gt; # font标签 2. 实体符号 &amp;nbsp; # 空格符 &lt; &amp;lt; &gt; &amp;gt; # 大于号、小于号 3. 表格 3.1 基本表格 &lt;table width=&quot;200px&quot; height=&quot;100px&quot; border=&quot;2px&quot;&gt; # 长宽、居中 &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;111&lt;/td&gt; &lt;td&gt;444&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot;&gt;222&lt;/td&gt; &lt;td&gt;555&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;333&lt;/td&gt; &lt;td&gt;666&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 3.2 表格合并 上下合并 &lt;rowspan=&quot;2&quot;&gt; &lt;table width=&quot;200px&quot; height=&quot;100px&quot; border=&quot;2px&quot;&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;111&lt;/td&gt; &lt;td rowspan=&quot;2&quot;&gt;444&lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;222&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 左右并列 &lt;colspan=&quot;2&quot;&gt; &lt;table width=&quot;200px&quot; height=&quot;100px&quot; border=&quot;2px&quot;&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td colspan=&quot;2&quot;&gt;111&lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;222&lt;/td&gt; &lt;td&gt;333&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 3.3 &lt;th&gt; 标签 居中并加粗 &lt;th&gt; &lt;table width=&quot;200px&quot; height=&quot;100px&quot; border=&quot;2px&quot;&gt; &lt;tr align=&quot;center&quot;&gt; &lt;th&gt;222&lt;/th&gt; &lt;th&gt;333&lt;/th&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;222&lt;/td&gt; &lt;td&gt;333&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 3.4 表格三部分 表头 &lt;thead&gt;、表体 &lt;tbody&gt;、表脚 &lt;tfoot&gt; 不显示在网页 &lt;table width=&quot;200px&quot; height=&quot;100px&quot; border=&quot;2px&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;222&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;/tbody&gt; &lt;tr&gt; &lt;td&gt;222&lt;/td&gt; &lt;/tr&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;222&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;/table&gt; 4. 背景颜色和背景图片 背景颜色 &lt;body bgcolor=&quot;red&quot;&gt; &lt;!--code--&gt; &lt;/body&gt; 背景图片 &lt;body background=&quot;pic.jpg&quot;&gt; &lt;!--code--&gt; &lt;/body&gt; 5. 图片 浮动于浏览器窗口的图片元素 width=&quot;&quot; 设置宽度,同时高度会等比例缩放 title=&quot;&quot; 鼠标悬停文字 alt=&quot;&quot; 图片不存在信息 &lt;img src=&quot;pic.jpg&quot; width=&quot;100px&quot; title=&quot;is a pic&quot; alt=&quot;no pic found&quot;&gt; 6. 超链接 6.1 href=&quot;&quot; 设置打开什么 &lt;!--绝对路径--&gt; &lt;a href=&quot;https://www.baidu.com&quot;&gt;baidu&lt;/a&gt; &lt;!--相对路径--&gt; &lt;a href=&quot;more&quot;&gt;baidu&lt;/a&gt; 6.2 target=&quot;&quot; 设置在哪打开 默认值是 _self _blank 新窗口显示 _self 当前窗口 _parent 父窗口 _top 顶级窗口（最外层） 内嵌窗口 &lt;iframe src=&quot;&quot;&gt;&lt;/iframe&gt; 7. 列表 7.1 有序列表 type=&quot;&quot; 序号样式 1 默认，数字编号 A 大写字母 a 小写字母 I 大写罗马编号 i 小写罗马编号 &lt;ol&gt; &lt;li&gt;chiana&lt;/li&gt; &lt;ol&gt; &lt;li&gt;11:20&lt;/li&gt; &lt;/ol&gt; &lt;li&gt;USA&lt;/li&gt; &lt;/ol&gt; 7.1 无序列表 type=&quot;&quot; 序号样式 circle 圆圈 square 方块 disc 实心圆 &lt;ul&gt; &lt;li&gt;china&lt;/li&gt; &lt;li&gt;USA&lt;/li&gt; &lt;/ul&gt; 无序嵌套无序列表 &lt;ul&gt; &lt;li&gt;china&lt;/li&gt; &lt;ul&gt; &lt;li&gt;shanghai&lt;/li&gt; &lt;li&gt;beijing&lt;/li&gt; &lt;/ul&gt; &lt;li&gt;USA&lt;/li&gt; &lt;/ul&gt; 8. 表单 8.1 什么是表单，有什么用 ? 表单可以用来收集用户的数据，提交表单时，可以向服务器发送请求，并且还可以携带用户填写的数据 8.2 基本表单 &lt;form action=&quot;&quot; method=&quot;&quot;&gt;&lt;/form&gt; action 属性用来指定请求路径，也就是说数据提交的时候，提交给谁 action 属性和超链接的 href 属性相同，都是提供“请求路径”的 method 属性用来指定表单提交的方式/方法，常见的包括两种: get方式提交 (默认) post方式提交 8.2 提交按钮 &lt;input type=&quot;submit&quot;&gt; 是个按钮，发送请求并提交数据 value 设置按钮文本 8.3 input 标签 type 属性可选项: text 文本框 password 密码框 radio 单选框 checkbox 多选框 name 属性 没有 name 属性，数据不会提交 会在提交时添加 name 和 返回值 到提交地址 value 属性 text 和 password 等由用户输入value的不用写 其他需要指定各个选项的value 8.4 其他标签 单选框 &lt;input type=&quot;radio&quot; name=&quot;same&quot; value=&quot;0&quot; checked&gt; &lt;input type=&quot;radio&quot; name=&quot;same&quot; value=&quot;1&quot;&gt; &lt;!-- 如果选项是一起的 `name` 属性要相同 --&gt; &lt;!-- `checked` 是默认选项 --&gt; 下拉列表 &lt;select name=&quot;&quot; id=&quot;&quot;&gt; &lt;option value=&quot;0&quot;&gt;&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;&lt;/option&gt; &lt;/select&gt; &lt;!-- `selected` 是默认选项 --&gt; 多选框 &lt;input type=&quot;checkbox&quot; name=&quot;same&quot; value=&quot;0&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;same&quot; value=&quot;1&quot;&gt; &lt;!-- 如果选项是一起的 `name` 属性要相同 --&gt; &lt;!-- `checked` 是默认选项 --&gt; 文本域 （多行文本框） &lt;textarea name=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; 重置按钮 使表单回到初始状态 &lt;input type=&quot;reset&quot; value=&quot;reset&quot;&gt; ","link":"https://blog.xn--fiqz59cpva341l.top/post/html-bi-ji-qi-yi/"},{"title":"Hadoop——Centos 7 安装 Hadoop（零）","content":"主要是告诉你怎么创建一个centos虚拟机 下载准备 下载VMware和centos镜像 下载Vmware 官方最新版直连：https://www.vmware.com/go/getworkstation-win 我的版本下载：https://download3.vmware.com/software/WKST-1700-WIN/VMware-workstation-full-17.0.0-20800274.exe 激活码：MC60H-DWHD5-H80U9-6V85M-8280D（来自www.ghxi.com） 下载Centos 官方站：https://www.centos.org/download/ 清华站：https://mirrors.tuna.tsinghua.edu.cn/centos 阿里站：https://mirrors.aliyun.com/centos/ 我的版本下载：https://mirrors.tuna.tsinghua.edu.cn/centos/7.9.2009/isos/x86_64/CentOS-7-x86_64-DVD-2009.iso 安装 开始安装VMware和在Vmware里安装centos7 安装VMware 没什么要注意的，无脑下一步 要写许可证的时候填一下开头的激活码 安装Centos虚拟机 按下 Ctrl+N 打开新建虚拟机向导 选择`典型` 下一步 选择`安装程序光盘映像文件` 点击`浏览`选择你刚刚下载的`CentOS-7-x86_64-DVD-2009.iso` 下一步 填写账号密码 这里我写`master` ,`master` ,`111111` ,`111111` 下一步 改名字和目录，不改也行，认得就好，空间大也无所谓 下一步 下一步 （可选） 打开`自定义硬件`，删除`打印机` `声卡` 甚至 `USB控制器` 下一步 此时虚拟机会打开 啥也不要干，等 大概5分钟（我是）会自动重启 进入登录界面，输入上面设的密码即可登录 恭喜 安装完成！ 部分体验优化（可选） 我强迫症不做会很难受 自动登录 右上角-用户名-展开-Account setting 右上角Unlock-输入密码-Automatic Login-改为ON 防止自动锁屏 左上角-application-system tools-Privacy Screen Lock-Automatic Screen Lock-改为OFF ","link":"https://blog.xn--fiqz59cpva341l.top/post/hadoop-centos-7-an-zhuang-hadoopling/"},{"title":"Hadoop——Centos 7 安装 Hadoop（二）","content":"主要是Hadoop的配置和启动 1.配置hadoop 占位 1.1添加环境变量 暂无 1.2修改 hadoop-env.sh cd /usr/hadoop-3.2.4/etc/hadoop/ # 这个目录是 hadoop的安装路径/etc/hadoop/ # 以下几乎所有操作都在这个目录进行 vim hadoop-env.sh # 为hadoop设置java路径 export JAVA_HOME=/usr/java/jdk1.8.0_202-amd64 # 设置一些参数 export HDFS_NAMENODE_USER=root export HDFS_DATANODE_USER=root export HDFS_SECONDARYNAMENODE_USER=root export YARN_RESOURCEMANAGER_USER=root export YARN_NODEMANAGER_USER=root 1.3修改 core-site.xml vim core-site.xml &lt;configuration&gt; &lt;!-- 指定 NameNode 的地址 --&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://node1:8020&lt;/value&gt; &lt;/property&gt; &lt;!-- 指定 hadoop 数据的存储目录 --&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/usr/hadoop-3.2.4&lt;/value&gt; &lt;/property&gt; &lt;!-- 配置 HDFS 网页登录使用的静态用户为 xxx --&gt; &lt;property&gt; &lt;name&gt;hadoop.http.staticuser.user&lt;/name&gt; &lt;value&gt;root&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 1.4修改 hdfs-site.xml vim hdfs-site.xml &lt;configuration&gt; &lt;!-- nn web 端访问地址--&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt; &lt;value&gt;node2:9868&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 1.5修改 mapred-site.xml vim mapred-site.xml # 指定MapReduce运行时的框架YARN &lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 1.6修改 yarn-site.xml vim yarn-site.xml &lt;configuration&gt; &lt;!-- 指定 ResourceManager 的地址--&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;node1&lt;/value&gt; &lt;/property&gt; &lt;!-- 指定 MR 走 shuffle --&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 1.7修改 workers vim workers 注释掉里面本来的localhost添加非node的虚拟机主机名 # 有几个加几个 node2 node3 2克隆虚拟机 磕磕 2.1克隆 先关闭当前虚拟机 路径：右键虚拟机-管理-克隆 中间选择完整克隆，路径自选，其余默认 2.2修改虚拟机主机名称 打开克隆虚拟机 vim /etc/hostname 把node1改为node2 2.3修改IP vim /etc/sysconfig/network-scripts/ifcfg-ens33 # 分配ip IPADDR=&quot;192.168.140.141(142,123)&quot; service network restart 2.4ssh免密登录配置 创建密钥 ssh-keygen 分发密钥 ssh-copy-id node1 ssh-copy-id node2 ssh-copy-id node3 一会让你输入yes还要输入密码 2.5 windows免密登录linux（可选） ssh-keygen -t rsa # 上传密钥 scp 生成的id_rsa.pub目录 root@IP地址:~/.ssh # 进入虚拟机终端 root@IP地址 cd .ssh/ # 追加密钥 cat id_rsa.pub &gt;&gt; authorized_keys 3启动hadoop 3.1启动 # 格式化集群 hdfs namenode -format # 启动（一键） start-all.sh # 启动（分布） start-dfs.sh start-yarn.sh 3.2打开web面板 # 虚拟机里，两个都应该打开 http://node1:8088 http://node1:9870 可以直接在windows浏览器打开http://node1的IP:8088http://node1的IP:9870看 ","link":"https://blog.xn--fiqz59cpva341l.top/post/centos-7-an-zhuang-hadoop-2/"},{"title":"Hadoop——Centos 7 安装 Hadoop（一）","content":"安装centos的过程不是难点不做介绍 介绍了，在Centos 7 安装 Hadoop（零） 1.配置网络 为你的虚拟机配置静态IP 1.0获取你虚拟机的当前IP 按照路径打开： VMware-编辑-虚拟网络编辑器-选择VMnet8-NET设置 记录： 子网IP 子网掩码 网关IP IP格式应该为192.168.aaa.0 aaa每人都可能不一样，我的是140 所以下文用192.168.140.0作为示例 1.1修改虚拟机主机名 vim /etc/hostname # 这个名字即下文的node1，node2等 1.2修改hosts 设置主机名和 ip 映射 在文件后面添加 ，要几个虚拟机写几行 这里的IP就是#1.0中的IP，但是结尾0的IP已经被占用 所以这里使用140开始的数字作为结尾即192.168.140.140 也可以使用其他好记的数字 后文输入命令的时候注意改动 vi /etc/hosts # 编辑文件 # 准备建几个虚拟机就写几个 192.168.140.140 node1 192.168.140.141 node2 1.3改静态ip vim /etc/sysconfig/network-scripts/ifcfg-ens33 # 把动态改为静态 BOOTPROTO=&quot;static&quot; # 手动添加网络配置 IPADDR=&quot;192.168.140.140&quot; # 前面说的还记得吧？ GATEWAY=&quot;192.168.140.2&quot; # 网关基本是`2`结尾 NETMASK=&quot;255.255.255.0&quot; DNS1=&quot;114.114.114.114&quot; 1.4重启网络 service network restart 1.5ssh连接 使用主机的shell连接到linux的终端 默认root用户登录防止频繁的su提权操作 ssh root@192.168.140.140 # 第一次输入yes并回车再输入密码 如果出现 WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! 输入下面代码重新连接即可 ssh-keygen -R IP地址 1.6关防火墙 关就是了，主机的也关下 firewall-cmd --state systemctl stop firewalld.service systemctl disable firewalld.service 1.7时间同步 ntpdate ntp1.aliyun.com 2.软件安装 安装java和hadoop，同时配置ftp服务 2.1卸载java 因为openjava不是完全体java # 查找 rpm -qa|grep java # 卸载 # 把上面查找的包全部删除 # 语法 rpm -e --nodeps 包名（后面的版本号可以不写） rpm -e --nodeps javapackages-tools rpm -e --nodeps java-1.8.0-openjdk rpm -e --nodeps java-1.7.0-openjdk rpm -e --nodeps java-1.7.0-openjdk-headless rpm -e --nodeps java-1.8.0-openjdk-headless rpm -e --nodeps python-javapackages rpm -e --nodeps tzdata-java 安装java在接下来的章节（点这里） 2.2安装FTP服务 # 安装 yum install -y vsftpd cd /etc/vsftpd/ vi vsftpd.conf # 修改以下配置 anonymous_enable=NO ascii_upload_enable=YES ascii_download_enable=YES chroot_local_user=YES chroot_list_enable=NO allow_writeable_chroot=YES 2.3打开FTP服务 systemctl enable vsftpd.service systemctl start vsftpd.service 2.4关闭SElinux 如果ftp连接出现500 OOPS: chroot则需要关闭 vim /etc/sysconfig/selinux 将SELINUX=enforcing 改为SELINUX=disabled 完成后需要重启机器 2.5连接FTP 使用任意客户端 打开ftp://192.168.140.140 账号为非root用户 2.6FTP root登录 （这一步不是必要的） linux默认禁止FTP以root用户登录 如果要，按照以下操作 vi /etc/vsftpd/ftpusers #注释掉root一行 2.7安装java 先下载java 下载地址： https://www.oracle.com/java/technologies/downloads/要登陆，很烦 https://repo.huaweicloud.com/java/jdk/华为镜像，不错 这里我们选择下载 https://repo.huaweicloud.com/java/jdk/8u202-b08/jdk-8u202-linux-x64.rpm 使用ftp传到虚拟机里(如果centos有图像界面直接火狐下载) 我是使用非root登录，传到了/home/用户名/Desktop里 回到终端 cd /home/用户名/Desktop # 火狐下载的直接打开下载目录 # 安装 rpm -ivh jdk-8u202-linux-x64.rpm 2.8配置java环境变量 # 打开环境变量配置文件 vi /etc/profile 文件最后添加 #JAVA_HOME export JAVA_HOME=/usr/java/jdk1.8.0_202-amd64 export PATH=$PATH:$JAVA_HOME/bin # 刷新环境变量使其生效 source /etc/profile # 测试是否安装成功 java javac # 如果有大段使用介绍输出就行 至此java配置成功 2.9安装Hadoop 上面的java有打包好的rpm格式的安装包可以直接安装，但是Hadoop没有，需要手动安装 官方下载地址： https://hadoop.apache.org/releases.html 网页里找到Binary download下载包 我使用这个版本： https://dlcdn.apache.org/hadoop/common/hadoop-3.2.4/hadoop-3.2.4.tar.gz 依旧是保存到/home/用户名/Desktop # 进入目录 cd /home/用户名/Desktop # 解压到/usr/ tar -zxvf hadoop-3.2.4.tar.gz -C /usr/ 2.10配置Hadoop环境变量 # 打开环境变量配置文件 vi /etc/profile 文件最后添加 ##HADOOP_HOME export HADOOP_HOME=/usr/hadoop-3.2.4 export PATH=$PATH:$HADOOP_HOME/bin export PATH=$PATH:$HADOOP_HOME/sbin # 刷新环境变量使其生效 source /etc/profile # 测试是否安装成功 hadoop version # 如果有非报错的输出就行 到此Hadoop安装完成 ","link":"https://blog.xn--fiqz59cpva341l.top/post/centos-7-an-zhuang-hadoop/"},{"title":"Android开发笔记——储存文件到Data","content":"麻烦死了 前言 教程里给出的实例，很长 我甚至不想仔细看 private void save(String a){ FileOutputStream out = null; BufferedWriter writer = null; try{ out = openFileOutput(&quot;data&quot;, Context.MODE_PRIVATE); writer = new BufferedWriter(new OutputStreamWriter(out)); writer.write(a); }catch (IOException e){ e.printStackTrace(); }finally { try { if(writer != null){ writer.close(); } }catch(IOException e){ e.printStackTrace(); } } } private String load(){ FileInputStream in = null; BufferedReader reader = null; StringBuilder content = new StringBuilder(); try { in = openFileInput(&quot;data&quot;); reader = new BufferedReader(new InputStreamReader(in)); String line = &quot;&quot;; while ((line = reader.readLine()) != null){ content.append(line); } }catch (IOException e){ e.printStackTrace(); }finally{ if(reader != null){ try{ reader.close(); }catch (IOException e){ e.printStackTrace(); } } } return content.toString(); } 于是 使用chatgpt为其添加了注释 感觉还是繁琐 private void save(String a){ //定义一个保存数据的函数，参数为数据内容 FileOutputStream out = null; //定义一个输出流 BufferedWriter writer = null; //定义一个缓冲写入器 try{ out = openFileOutput(&quot;data&quot;, Context.MODE_PRIVATE); //打开名为&quot;data&quot;的文件进行文件输出 writer = new BufferedWriter(new OutputStreamWriter(out)); //将输出流传递给缓冲写入器 writer.write(a); //写入字符串形式的数据内容 }catch (IOException e){ //捕获可能发生的I/O异常 e.printStackTrace(); //输出异常栈信息 }finally { //保证无论如何都会执行的最终操作 try { if(writer != null){ //如果缓冲写入器不为空 writer.close(); //则将其关闭 } }catch(IOException e){ //捕获可能发生的I/O异常 e.printStackTrace(); //输出异常栈信息 } } } private String load(){ //定义一个读取数据的函数，返回值为字符串类型的数据内容 FileInputStream in = null; //定义一个输入流 BufferedReader reader = null; //定义一个缓冲读取器 StringBuilder content = new StringBuilder(); //定义一个字符串构建器，用于将读取的数据拼接成完整的字符串 try { in = openFileInput(&quot;data&quot;); //打开名为&quot;data&quot;的文件进行文件输入 reader = new BufferedReader(new InputStreamReader(in)); //将输入流传递给缓冲读取器 String line = &quot;&quot;; //定义一个字符串变量用于存储读取到的每一行数据 while ((line = reader.readLine()) != null){ //每次读取一行数据，如果不为空就继续 content.append(line); //将这行数据添加到字符串构建器中 } }catch (IOException e){ //捕获可能发生的I/O异常 e.printStackTrace(); //输出异常栈信息 }finally{ //保证无论如何都会执行的最终操作 if(reader != null){ //如果缓冲读取器不为空 try{ reader.close(); //则将其关闭 }catch (IOException e){ //捕获可能发生的I/O异常 e.printStackTrace(); //输出异常栈信息 } } } return content.toString(); //将字符串构建器中拼接好的数据内容以字符串形式返回 } 我觉得一个保存读取不该这么长 于是询问 chatgpt给出的化简方案 // 以上代码已经很简单和高效了，不过可以使用Java 7引入的Try-With-Resources方法，可以进一步简化代码并且不需要在finally块中手动关闭资源。以下是更新后的代码： private void save(String a) { try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter( openFileOutput(&quot;data&quot;, Context.MODE_PRIVATE)))) { writer.write(a); } catch (IOException e) { e.printStackTrace(); } } private String load() { StringBuilder content = new StringBuilder(); try (BufferedReader reader = new BufferedReader(new InputStreamReader( openFileInput(&quot;data&quot;)))) { String line; while ((line = reader.readLine()) != null) { content.append(line); } } catch (IOException e) { e.printStackTrace(); } return content.toString(); } // 这段更新后的代码使用try-with-resources语句简化了底层的IO操作，并且自动关闭资源，而且不需要显式的声明FileInputStream和FileOutputStream对象，可以直接使用Context的openFileInput和openFileOutput方法。 尽管看起来简单了但是差点意思 看来异常处理的部分是不可省略的 不可能每次读取都手打这么多 最好有个模板 正文 基本是个可以复制的八股文了 其中try部分是可改的有效代码 根据需要处理 缺点是一个数据要放一个文件 保存方法 private void save(String content ,String file){ FileOutputStream out = null; BufferedWriter writer = null; try{ out = openFileOutput(file, Context.MODE_PRIVATE); //打开名为&quot;data&quot;的文件进行文件输出 writer = new BufferedWriter(new OutputStreamWriter(out)); //将输出流传递给缓冲写入器 writer.write(content); //写入字符串形式的数据内容 // 捕获异常 }catch (IOException e){ e.printStackTrace(); }finally { try { if(writer != null){ writer.close(); } }catch(IOException e){ e.printStackTrace(); } } } 输入的两个参数：要保存的数据，要保存的地方 读取方法 private String load(String file){ FileInputStream in = null; BufferedReader reader = null; StringBuilder content = new StringBuilder(); //定义一个字符串构建器，用于将读取的数据拼接成完整的字符串 try { in = openFileInput(file); reader = new BufferedReader(new InputStreamReader(in)); String line = &quot;&quot;; while ((line = reader.readLine()) != null){ //每次读取一行数据，如果不为空就继续 content.append(line); //将这行数据添加到字符串构建器中 } // 捕获异常 }catch (IOException e){ e.printStackTrace(); }finally{ if(reader != null){ try{ reader.close(); }catch (IOException e){ e.printStackTrace(); } } } return content.toString(); //数据返回 } 输入的一个参数：保存的地方 输出的一个参数：读到的数据 ","link":"https://blog.xn--fiqz59cpva341l.top/post/android-kai-fa-bi-ji-chu-cun-wen-jian-dao-data/"},{"title":"Android开发笔记——AS终端报错乱码的解决","content":"之前一直困惑终端报错内容是♦♦♦♦♦♦♦♦，今天查询一下找到了解决方法 原因 终端的编码设置问题 解决方法 1.在AS双击shift 2.在弹出的窗口输入输入vmoption 3.选择Edit Custom CM Options 4.打开文件加入一行-Dfile.encoding=UTF-8 5.重新同步 6.重启Android Studio ","link":"https://blog.xn--fiqz59cpva341l.top/post/android-kai-fa-bi-ji-as-zhong-duan-bao-cuo-luan-ma-de-jie-jue/"},{"title":"Android开发笔记——更改安卓项目的包名","content":"这步骤真麻烦，不过也不常用 第一步 在Android Studio中把项目切换到Android视图 点击java下的包名文件夹 右键Refactor，Rename IDE会自动重命名相关内容 第二部 打开build.gradle 找到applicationId &quot;&quot;和namespace '' 修改其包名内容 第三步 最后点击Sync Now 重新打包apk即可 ","link":"https://blog.xn--fiqz59cpva341l.top/post/android-kai-fa-bi-ji-geng-gai-an-zhuo-xiang-mu-de-bao-ming/"},{"title":"Android开发笔记——打包APK","content":"分CPU架构打包 找到app下的build.gradle文件，在android{}里加入 splits { abi { enable true universalApk true } } 最后点击Sync Now 重新打包apk即可 修改打包输出文件名 找到app下的build.gradle文件，在android{}里加入 applicationVariants.all { variant -&gt; variant.outputs.all { output -&gt; outputFileName = outputFileName.replace(&quot;app&quot;, &quot;newappname&quot; + versionName) } } app：初始文件名称开头 newappname：新的文件名称开头 最后点击Sync Now 重新打包apk即可 资源文件混淆压缩 找到app下的build.gradle文件 在android{ buildTypes { }}里 找到你要取消混淆的构建类型修改 minifyEnabled false shrinkResources false // 禁用代码混淆和资源缩减 zipAlignEnabled true //压缩 最后点击Sync Now ","link":"https://blog.xn--fiqz59cpva341l.top/post/android-kai-fa-bi-ji-da-bao-apk/"},{"title":"Android开发笔记——EditText的使用","content":"EditText是单行文本编辑，与其他控件有点不一样 创建一个文本框对象 EditText editText = findViewById(R.id.editText); 为文本框设置文本改变监听器 其中： beforeTextChanged在文本发生变化之前调用，可以在此方法中处理一些文本变化之前的逻辑，例如对输入的文本进行验证或格式化等操作。 onTextChanged最常用的用于及时保存用户输入 还有实时显示文本的长度、对输入的文本进行实时过滤 afterTextChanged获取文本框中的最终文本，并进行相应的处理，例如将文本存储到数据库中、触发搜索操作等。 editText.addTextChangedListener(new TextWatcher() { @Override public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) { // 在用户输入前执行的动作 } @Override public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) { // 在用户输入文本改变时触发的动作 } @Override public void afterTextChanged(Editable editable) { // 在用户完成文本输入完成时触发的动作 } }); ","link":"https://blog.xn--fiqz59cpva341l.top/post/android-kai-fa-bi-ji-edittext-de-shi-yong/"},{"title":"Android开发笔记——Switch的使用","content":"Switch是一个开关控件 Switch switch1 = (Switch) findViewById(R.id.switch1); 常用方法 设置选中状态 switch1.setChecked(true); 设置控件是否可以更改 switch1.setEnabled(true); 开关的点击切换事件 为switch创建选中改变监听器 其中onCheckedChanged传入的boolean b是开关改变后的布尔值 不要使用b，请直接使用自己的变量 switch1.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() { @Override public void onCheckedChanged(CompoundButton compoundButton, boolean b) { // 此处写开关状态改变后要执行的代码 } }); 一般会设置打开开关与关闭开关执行不同的代码 switch1.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() { @Override public void onCheckedChanged(CompoundButton compoundButton, boolean b) { if(b){ // 打开开关执行的代码 }else{ // 关闭开关执行的代码 } } }); ","link":"https://blog.xn--fiqz59cpva341l.top/post/android-kai-fa-bi-ji-switch-de-shi-yong/"},{"title":"Android开发笔记——控件的点击事件","content":"给按钮添加一个点击事件 经过测试，不单单是按钮，图片等其他控件也可以设置 创建对象 Button button1 = (Button) findViewById(R.id.button); // 创建Button对象 ## 单击事件 button1.setOnClickListener(new View.OnClickListener() { // 创建点击监听器 @Override public void onClick(View view) { // 要执行的点击事件 } }); 双击事件 button1.setOnDoubleClickListener(new View.OnDoubleClickListener() { @Override public void onDoubleClick(View v) { // 双击事件操作 } }); ","link":"https://blog.xn--fiqz59cpva341l.top/post/android-kai-fa-bi-ji-kong-jian-de-dian-ji-shi-jian/"},{"title":"Android开发笔记——新的活动和活动间的跳转","content":"应用有多个活动一定会用到活动之间的跳转 创建新的活动 项目包名下右键new-&gt;Activity-&gt;Empty Activity即可创建新的活动 默认IDE应该会自动帮你 在AndroidManifest.xml注册活动 创建布局XML 创建JAVA类的onCreate方法 活动间的跳转 用法： public Intent(android.content.Context packageContext,Class&lt;?&gt; cls ) 第一个大概是本活动.this 第二个大概是目标活动.class 示例： Intent intent = new Intent(MainActivity.this, Setting.class); startActivity(intent); ","link":"https://blog.xn--fiqz59cpva341l.top/post/android-kai-fa-bi-ji-xin-de-huo-dong-he-huo-dong-jian-de-tiao-zhuan/"},{"title":"Android开发笔记——应用的沉浸显示","content":"使你的App更好的显示在各种设备 隐藏默认标题栏 修改res/values/themes.xml 把这个 &lt;style name=&quot;Theme.MyApplication&quot; parent=&quot;Theme.MaterialComponents.DayNight.DarkActionBar&quot;&gt; 的parent改成NoActionBar 例如 &lt;style name=&quot;Theme.MyApplication&quot; parent=&quot;Theme.MaterialComponents.DayNight.NoActionBar&quot;&gt; 就可以实现隐藏标题栏 应用全屏显示 在窗口的onCreate方法中加入 getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); 隐藏三大金刚或者小白条 在MainActivity类下添加以下代码 @Override protected void onResume() { super.onResume(); View decorView = getWindow().getDecorView(); int uiOptions = View.SYSTEM_UI_FLAG_HIDE_NAVIGATION; decorView.setSystemUiVisibility(uiOptions); } 可能需要以下权限，它允许应用程序在屏幕上显示弹出窗口 在AndroidManifest.xml里加入 &lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;/&gt; 适配全面屏 部分情况下如果设备有刘海会出现黑条，这种情况在theme.xml等文件里设置style加入以下代码 &lt;item name=&quot;android:windowTranslucentNavigation&quot;&gt;true&lt;/item&gt; ","link":"https://blog.xn--fiqz59cpva341l.top/post/android-kai-fa-bi-ji-ying-yong-de-chen-jin-xian-shi/"},{"title":"Android开发笔记——对话框","content":"创建一个悬浮于当前窗口的对话框 一、普通对话框 示例： AlertDialog.Builder dialog = new AlertDialog.Builder(MainActivity.this); // 创建对象 dialog.setTitle(&quot;你干嘛~&quot;); dialog.setCancelable(false); // 设置能否点击空白处关闭对话框 dialog.setMessage(&quot;小黑子食不食油饼！&quot;); dialog.setPositiveButton(&quot;食！&quot;,new DialogInterface.OnClickListener() { // 点击事件 }); dialog.show(); // 显示对话框 常用方法： dialog.setCancelable(bool) // 设置能否点击空白处关闭对话框 setTitle、setMessage、setIcon // 构造对话框的标题、信息和图标等内容 setPositive/Negative/NeutralButton() // 设置正面按钮、负面按钮和中立按钮 二、进度对话框 对话框左边有个一直旋转的圆形进度条 示例： ProgressDialog progressDialog = new ProgressDialog(MainActivity.this); progressDialog.setTitle(&quot;标题&quot;); progressDialog.setMessage(&quot;提示信息&quot;); progressDialog.setCancelable(false); progressDialog.show(); 可以设置对话框一段时间后后关闭 new Handler().postDelayed(new Runnable() { @Override public void run() { progressDialog.dismiss(); // 其他代码 } }, 2000); ","link":"https://blog.xn--fiqz59cpva341l.top/post/android-kai-fa-bi-ji-dui-hua-kuang/"},{"title":"Android开发笔记——Toast的发送","content":"在屏幕下方发送一个Toast提示 用法： Toast.makeText(context,text,duration ).show(); // context 窗口 // text 文本内容 // duration 通知停留长度 // Toast.LENGTH_SHORT = 0 // Toast.LENGTH_LONG = 1 示例： Toast.makeText(MainActivity.this, &quot;你让我拿什么励志？&quot;,Toast.LENGTH_SHORT).show(); ","link":"https://blog.xn--fiqz59cpva341l.top/post/android-kai-fa-bi-ji-toast-de-fa-song/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://blog.xn--fiqz59cpva341l.top/post/hello-gridea/"}]}